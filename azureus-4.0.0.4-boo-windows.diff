diff -urN org/gudy/azureus2/platform.orig/macosx/access/cocoa/CocoaJavaBridge.java org/gudy/azureus2/platform/macosx/access/cocoa/CocoaJavaBridge.java
--- org/gudy/azureus2/platform.orig/macosx/access/cocoa/CocoaJavaBridge.java	2008-02-08 17:21:08.000000000 -0800
+++ org/gudy/azureus2/platform/macosx/access/cocoa/CocoaJavaBridge.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,347 +0,0 @@
-package org.gudy.azureus2.platform.macosx.access.cocoa;
-
-/*
- * Created on 27-Mar-2005
- * Created by James Yeh
- * Copyright (C) 2004-2005 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-import com.apple.cocoa.foundation.NSAppleEventDescriptor;
-import com.apple.cocoa.foundation.NSAppleScript;
-import com.apple.cocoa.foundation.NSAutoreleasePool;
-import com.apple.cocoa.foundation.NSMutableDictionary;
-import org.gudy.azureus2.core3.logging.*;
-import org.gudy.azureus2.core3.util.AEMonitor;
-import org.gudy.azureus2.core3.util.AERunnable;
-import org.gudy.azureus2.core3.util.AEThread;
-import org.gudy.azureus2.core3.util.Debug;
-import org.gudy.azureus2.platform.macosx.NativeInvocationBridge;
-
-import java.io.File;
-import java.text.MessageFormat;
-
-/**
- * <p>Performs PlatformManager tasks using Cocoa-Java (FoundationKit only)</p>
- * <p>For now, operations are performed using NSAppleScript, rather than using NSWorkspace.
- * This is still significantly faster than calling the cmd-line osascript.</p>
- * @version 2.1 Apr 2, 2005
- */
-public final class CocoaJavaBridge extends NativeInvocationBridge
-{
-    /**
-     * The path the Cocoa-Java class files are located at
-     */
-    protected static final String CLASS_PATH = "/system/library/java";
-
-    private static final String REVEAL_SCRIPT_FORMAT = "tell application \"System Events\"\ntell application \"{0}\"\nactivate\nreveal (posix file \"{1}\" as alias)\nend tell\nend tell";
-
-    private static final String DEL_SCRIPT_FORMAT = "tell application \"Finder\" to move (posix file \"{0}\" as alias) to the trash";
-
-    /**
-     * Main NSAutoreleasePool
-     */
-    private int mainPool;
-
-    protected AEMonitor classMon = new AEMonitor("CocoaJavaBridge:C");
-    private AEMonitor scriptMon = new AEMonitor("CocoaJavaBridge:S");
-
-    protected boolean isDisposed = false;
-
-    protected RunnableDispatcher scriptDispatcher;
-
-    public CocoaJavaBridge()
-    {
-        try
-        {
-            classMon.enter();
-            mainPool = NSAutoreleasePool.push();
-
-            scriptDispatcher = new RunnableDispatcher();
-        }
-        finally
-        {
-            classMon.exit();
-        }
-    }
-
-    // interface implementation
-
-    /**
-     * {@inheritDoc}
-     */
-    protected boolean performRecoverableFileDelete(File path)
-    {
-        if(!path.exists())
-            return false;
-
-        NSAppleEventDescriptor result =  executeScriptWithAsync(DEL_SCRIPT_FORMAT, new Object[]{path.getAbsolutePath()});
-        return (result != null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-	protected boolean showInFinder(File path, String fileBrowserApp) {
-		if (!path.exists())
-			return false;
-
-		NSAppleEventDescriptor result = null;
-		int pool = NSAutoreleasePool.push();
-		try {
-			result = executeScriptWithAsync(REVEAL_SCRIPT_FORMAT, new Object[] {
-				fileBrowserApp,
-				path.getAbsolutePath()
-			});
-		} finally {
-			NSAutoreleasePool.pop(pool);
-		}
-		return (result != null);
-	}
-
-    /**
-     * {@inheritDoc}
-     */
-    protected boolean isEnabled()
-    {
-        // simple check with classpath
-        return System.getProperty("java.class.path").toLowerCase().indexOf(CLASS_PATH) != -1;
-    }
-
-    // class utility methods
-
-    /**
-     * <p>Executes a new instance of NSAppleScript</p>
-     * <p>The method is wrapped in an autorelease pool and an AEMonitor. If there are
-     * no format parameters, MessageFormat is not used to parse the format string, and
-     * the format string will be treated as the source itself.</p>
-     * @see MessageFormat#format(String, Object...)
-     * @see NSAppleScript#execute(com.apple.cocoa.foundation.NSMutableDictionary)
-     */
-    protected final NSAppleEventDescriptor executeScript(String scriptFormat, Object[] params)
-    {
-        try
-        {
-            scriptMon.enter();
-
-            int pool = NSAutoreleasePool.push();
-            long start = System.currentTimeMillis();
-
-            String src;
-            if(params == null || params.length == 0)
-            {
-                src = scriptFormat;
-            }
-            else
-            {
-                src = MessageFormat.format(scriptFormat, params);
-            }
-
-            Debug.outNoStack("Executing: \n" + src);
-
-            NSAppleScript scp = new NSAppleScript(src);
-            NSAppleEventDescriptor result =  scp.execute(new NSMutableDictionary());
-
-            Debug.outNoStack(MessageFormat.format("Elapsed time: {0}ms\n", new Object[]{new Long(System.currentTimeMillis() - start)}));
-            NSAutoreleasePool.pop(pool);
-            return result;
-        }
-        finally
-        {
-            scriptMon.exit();
-        }
-    }
-
-    /**
-     * <p>Executes a new instance of NSAppleScript in a forked AEThread</p>
-     * <p>This method always returns a "true" event descriptor. Callbacks are currently unsupported
-     * , so in the event of an error, the logger is autuomatically notified.</p>
-     * <p>The thread's runSupport method is wrapped in an autorelease pool. If there are
-     * no format parameters, MessageFormat is not used to parse the format string, and
-     * the format string will be treated as the source itself.</p>
-     * @see org.gudy.azureus2.core3.util.AEThread#runSupport()
-     * @see MessageFormat#format(String, Object...)
-     * @see NSAppleScript#execute(com.apple.cocoa.foundation.NSMutableDictionary)
-     * @return NSAppleEventDescriptor.descriptorWithBoolean(true)
-     */
-    protected final NSAppleEventDescriptor executeScriptWithNewThread(final String scriptFormat, final Object[] params)
-    {
-        Thread worker = new AEThread("ScriptObject", true)
-        {
-            public void runSupport()
-            {
-                int pool = NSAutoreleasePool.push();
-                long start = System.currentTimeMillis();
-
-                String src;
-                if(params == null || params.length == 0)
-                {
-                    src = scriptFormat;
-                }
-                else
-                {
-                    src = MessageFormat.format(scriptFormat, params);
-                }
-
-                Debug.outNoStack("Executing: \n" + src);
-
-                NSMutableDictionary errorInfo = new NSMutableDictionary();
-                if(new NSAppleScript(src).execute(errorInfo) == null)
-                {
-                    Debug.out(String.valueOf(errorInfo.objectForKey(NSAppleScript.AppleScriptErrorMessage)));
-                    //logWarning(String.valueOf(errorInfo.objectForKey(NSAppleScript.AppleScriptErrorBriefMessage)));
-                }
-
-                Debug.outNoStack(MessageFormat.format("Elapsed time: {0}ms\n", new Object[]{new Long(System.currentTimeMillis() - start)}));
-                NSAutoreleasePool.pop(pool);
-            }
-        };
-
-        worker.setPriority(Thread.NORM_PRIORITY - 1);
-        worker.start();
-
-        return NSAppleEventDescriptor.descriptorWithBoolean(true);
-    }
-
-    /**
-     * <p>Asynchronously executes a new instance of NSAppleScript</p>
-     * <p>This method always returns a "true" event descriptor. Callbacks are currently unsupported
-     * , so in the event of an error, the logger is autuomatically notified.</p>
-     * <p>The thread's runSupport method is wrapped in an autorelease pool. If there are
-     * no format parameters, MessageFormat is not used to parse the format string, and
-     * the format string will be treated as the source itself.</p>
-     * @see org.gudy.azureus2.core3.util.AEThread#runSupport()
-     * @see MessageFormat#format(String, Object...)
-     * @see NSAppleScript#execute(com.apple.cocoa.foundation.NSMutableDictionary)
-     * @return NSAppleEventDescriptor.descriptorWithBoolean(true)
-     */
-    protected final NSAppleEventDescriptor executeScriptWithAsync(final String scriptFormat, final Object[] params)
-    {
-        final AERunnable worker = new AERunnable()
-        {
-            public void runSupport()
-            {
-                int pool = NSAutoreleasePool.push();
-                long start = System.currentTimeMillis();
-
-                String src;
-                if(params == null || params.length == 0)
-                {
-                    src = scriptFormat;
-                }
-                else
-                {
-                    src = MessageFormat.format(scriptFormat, params);
-                }
-
-                Debug.outNoStack("Executing: \n" + src);
-
-                NSMutableDictionary errorInfo = new NSMutableDictionary();
-                if(new NSAppleScript(src).execute(errorInfo) == null)
-                {
-                    Debug.out(String.valueOf(errorInfo.objectForKey(NSAppleScript.AppleScriptErrorMessage)));
-                    //logWarning(String.valueOf(errorInfo.objectForKey(NSAppleScript.AppleScriptErrorBriefMessage)));
-                }
-
-                Debug.outNoStack(MessageFormat.format("Elapsed time: {0}ms\n", new Object[]{new Long(System.currentTimeMillis() - start)}));
-                NSAutoreleasePool.pop(pool);
-            }
-        };
-
-        AEThread t = new AEThread("ScriptObject", true)
-        {
-            public void runSupport()
-            {
-                scriptDispatcher.exec(worker);
-            }
-        };
-        t.setPriority(Thread.NORM_PRIORITY - 1);
-        t.start();
-
-        return NSAppleEventDescriptor.descriptorWithBoolean(true);
-    }
-
-    /**
-     * Logs a warning message to Logger. The class monitor is used.
-     * @param message A warning message
-     */
-    private void logWarning(String message)
-    {
-        try
-        {
-            classMon.enter();
-            Logger.log(new LogAlert(LogAlert.UNREPEATABLE, LogAlert.AT_WARNING, message));
-        }
-        finally
-        {
-            classMon.exit();
-        }
-    }
-
-    // disposal
-
-    /**
-     * {@inheritDoc}
-     */
-    protected void dispose()
-    {
-        try
-        {
-            classMon.enter();
-            if(!isDisposed)
-            {
-                Debug.outNoStack("Disposing Native PlatformManager...");
-                NSAutoreleasePool.pop(mainPool);
-                isDisposed = true;
-                Debug.outNoStack("Done");
-            }
-        }
-        finally
-        {
-            classMon.exit();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    protected void finalize() throws Throwable
-    {
-        dispose();
-        super.finalize();
-    }
-
-    /**
-     * A dispatch object to help facilitate asychronous script execution (from the main thread) in a more
-     * predictable fashion.
-     */
-    private static class RunnableDispatcher
-    {
-        /**
-         * Executes a Runnable object while synchronizing the RunnableDispatcher instance.
-         * @param runnable A Runnable
-         */
-        private void exec(Runnable runnable)
-        {
-            synchronized(this)
-            {
-                runnable.run();
-            }
-        }
-    }
-}
Binary files org/gudy/azureus2/platform.orig/macosx/access/jnilib/libOSXAccess.jnilib and org/gudy/azureus2/platform/macosx/access/jnilib/libOSXAccess.jnilib differ
diff -urN org/gudy/azureus2/platform.orig/macosx/access/jnilib/make.mak org/gudy/azureus2/platform/macosx/access/jnilib/make.mak
--- org/gudy/azureus2/platform.orig/macosx/access/jnilib/make.mak	2006-07-21 09:21:40.000000000 -0700
+++ org/gudy/azureus2/platform/macosx/access/jnilib/make.mak	1969-12-31 16:00:00.000000000 -0800
@@ -1,12 +0,0 @@
-SDK = /Developer/SDKs/MacOSX10.4u.sdk
-ARCHS = -arch i386 -arch ppc
-LFLAGS = -bundle -isysroot $(SDK) $(ARCHS) -framework JavaVM -framework Carbon 
-CFLAGS = -c $(ARCHS) -I $(SDK)/System/Library/Frameworks/JavaVM.framework/Headers -I $(SDK)/System/Library/Frameworks/ApplicationServices.framework/Versions/A/Frameworks/AE.framework/Versions/A/Headers
-
-
-OBJECTS = OSXAccess.o
-OUTLIB = libOSXAccess.jnilib
-
-all:
-	cc $(CFLAGS) OSXAccess.c
-	cc -o $(OUTLIB) $(LFLAGS) $(OBJECTS)
diff -urN org/gudy/azureus2/platform.orig/macosx/access/jnilib/OSXAccess.c org/gudy/azureus2/platform/macosx/access/jnilib/OSXAccess.c
--- org/gudy/azureus2/platform.orig/macosx/access/jnilib/OSXAccess.c	2007-03-07 17:40:26.000000000 -0800
+++ org/gudy/azureus2/platform/macosx/access/jnilib/OSXAccess.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,127 +0,0 @@
-#include <Carbon/Carbon.h>
-#include <jni.h>
-#include <AEDataModel.h>
-
-#define VERSION "1.03"
-
-/**
- * AEDesc code from SWT, os_structs.c
- * Copyright (c) 2000, 2006 IBM Corporation and others.
- */
-typedef struct AEDesc_FID_CACHE {
-	int cached;
-	jclass clazz;
-	jfieldID descriptorType, dataHandle;
-} AEDesc_FID_CACHE;
-
-AEDesc_FID_CACHE AEDescFc;
-
-void cacheAEDescFields(JNIEnv *env, jobject lpObject)
-{
-	if (AEDescFc.cached) return;
-	AEDescFc.clazz = (*env)->GetObjectClass(env, lpObject);
-	AEDescFc.descriptorType = (*env)->GetFieldID(env, AEDescFc.clazz, "descriptorType", "I");
-	AEDescFc.dataHandle = (*env)->GetFieldID(env, AEDescFc.clazz, "dataHandle", "I");
-	AEDescFc.cached = 1;
-}
-
-AEDesc *getAEDescFields(JNIEnv *env, jobject lpObject, AEDesc *lpStruct)
-{
-	if (!AEDescFc.cached) cacheAEDescFields(env, lpObject);
-	lpStruct->descriptorType = (DescType)(*env)->GetIntField(env, lpObject, AEDescFc.descriptorType);
-	lpStruct->dataHandle = (AEDataStorage)(*env)->GetIntField(env, lpObject, AEDescFc.dataHandle);
-	return lpStruct;
-}
-
-void setAEDescFields(JNIEnv *env, jobject lpObject, AEDesc *lpStruct)
-{
-	if (!AEDescFc.cached) cacheAEDescFields(env, lpObject);
-	(*env)->SetIntField(env, lpObject, AEDescFc.descriptorType, (jint)lpStruct->descriptorType);
-	(*env)->SetIntField(env, lpObject, AEDescFc.dataHandle, (jint)lpStruct->dataHandle);
-}
-
-JNIEXPORT jint JNICALL Java_org_gudy_azureus2_platform_macosx_access_jnilib_OSXAccess_AEGetParamDesc
-	(JNIEnv *env, jclass that, jint theAppleEvent, jint theAEKeyword, 
-	 jint desiredType, jobject result)
-{
-	AEDesc _result, *lpresult=NULL;
-	
-	jint rc = 0;
-
-	if (result) if ((lpresult = getAEDescFields(env, result, &_result)) == NULL) goto fail;
-	
-	rc = (jint)AEGetParamDesc((const AppleEvent *)theAppleEvent, 
-	  (AEKeyword)theAEKeyword,
-	  (DescType)desiredType,
-	  (AEDescList *)lpresult);
-
-fail:
-	if (result && lpresult) setAEDescFields(env, result, lpresult);
-
-	return rc;
-}
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_macosx_access_jnilib_OSXAccess_getVersion(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	jstring	result =(*env)->NewStringUTF(env, (char *)VERSION);
-
-	return( result );
-}
-
-JNIEXPORT jstring JNICALL
-Java_org_gudy_azureus2_platform_macosx_access_jnilib_OSXAccess_getDocDir(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	CFURLRef docURL;
-	CFStringRef docPath;
-	FSRef    fsRef;
-  OSErr    err = FSFindFolder(kUserDomain, kDocumentsFolderType, kDontCreateFolder, &fsRef);
-  
-  jstring result = 0;
-
-	if (err == noErr) {
-  	if((docURL = CFURLCreateFromFSRef( kCFAllocatorSystemDefault, &fsRef))) {
-			docPath = CFURLCopyFileSystemPath(docURL, kCFURLPOSIXPathStyle);
-			
-			if (docPath) {
-				// convert to unicode
-				CFIndex strLen = CFStringGetLength( docPath );
-				UniChar uniStr[ strLen ];
-				CFRange strRange;
-				strRange.location = 0;
-				strRange.length = strLen;
-				CFStringGetCharacters( docPath, strRange, uniStr );
-	
-				result = (*env)->NewString( env, (jchar*)uniStr, (jsize)strLen );
-
-				CFRelease(docPath);
-				
-				return result;
-			}
-			CFRelease(docURL);
-		}
-
-		return result;
-  }
-}
-
-JNIEXPORT void JNICALL
-Java_org_gudy_azureus2_platform_macosx_access_jnilib_OSXAccess_memmove(
-	JNIEnv *env,
-	jclass cla,
-	jbyteArray dest,
-	jint src,
-	jint count)
-{
-	jbyte *dest1;
-	
-	if (dest) {
-		dest1 = (*env)->GetByteArrayElements(env, dest, NULL);
-		memmove((void *)dest1, (void *)src, count);
-		(*env)->ReleaseByteArrayElements(env, dest, dest1, 0);
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/macosx/access/jnilib/OSXAccess.java org/gudy/azureus2/platform/macosx/access/jnilib/OSXAccess.java
--- org/gudy/azureus2/platform.orig/macosx/access/jnilib/OSXAccess.java	2007-03-07 16:49:10.000000000 -0800
+++ org/gudy/azureus2/platform/macosx/access/jnilib/OSXAccess.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,58 +0,0 @@
-/*
- * Created on Jul 21, 2006 3:19:03 PM
- * Copyright (C) 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- */
-package org.gudy.azureus2.platform.macosx.access.jnilib;
-
-import org.eclipse.swt.internal.carbon.AEDesc;
-
-import org.gudy.azureus2.core3.util.*;
-
-/**
- * @author TuxPaper
- * @created Jul 21, 2006
- *
- */
-public class OSXAccess
-{
-	private static boolean bLoaded = false;
-
-	static {
-		try {
-			System.loadLibrary ("OSXAccess");
-			System.out.println("OSXAccess v" + getVersion() + " Load complete!");
-			bLoaded = true;
-		} catch (UnsatisfiedLinkError e1) {
-			Debug.out("Could not find libOSXAccess.jnilib");
-		}
-	}
-
-	public static final native int AEGetParamDesc(int theAppleEvent, int theAEKeyword, int desiredType, AEDesc result);
-
-	public static final native String getVersion();
-
-	// 1.02
-	public static final native String getDocDir();
-	
-	// 1.03
-	public static final native void memmove(byte[] dest, int src, int size);
-	
-	public static boolean isLoaded() {
-		return bLoaded;
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/macosx/NativeInvocationBridge.java org/gudy/azureus2/platform/macosx/NativeInvocationBridge.java
--- org/gudy/azureus2/platform.orig/macosx/NativeInvocationBridge.java	2008-02-08 17:21:06.000000000 -0800
+++ org/gudy/azureus2/platform/macosx/NativeInvocationBridge.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,96 +0,0 @@
-package org.gudy.azureus2.platform.macosx;
-
-/*
- * Created on 26-Mar-2005
- * Created by James Yeh
- * Copyright (C) 2004-2005 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-import org.gudy.azureus2.core3.util.Debug;
-
-import java.io.File;
-
-/**
- * <p>Performs PlatformManager and platform-specific tasks using bridges like Cocoa-Java -> ObjC</p>
- * <p>The methods supplied are intended to reflect those that can be dealt with a way other than
- * OSAScript. Ensure that the method signatures match those of PlatformManagerImpl, but
- * they should generally return a boolean (false for failure).</p>
- * @version 1.0
- */
-public abstract class NativeInvocationBridge
-{
-    private static NativeInvocationBridge instance;
-
-    protected NativeInvocationBridge(){}
-
-    static
-    {
-        try
-        {
-            Object newInstance = Class.forName("org.gudy.azureus2.platform.macosx.access.cocoa.CocoaJavaBridge").getConstructor(null).newInstance(null);
-            instance = (NativeInvocationBridge)newInstance;
-        }
-        catch(Exception e)
-        {
-            Debug.out(e);
-            instance = new DummyBridge();
-        }
-    }
-
-    /**
-     * Gets the singleton
-     * @return The NativeInvocationBridge singleton
-     */
-    protected static final NativeInvocationBridge sharedInstance()
-    {
-        return instance;
-    }
-
-     /**
-     * @see PlatformManager#performRecoverableFileDelete(java.io.File)
-     */
-     protected boolean performRecoverableFileDelete(File path) {return false;}
-
-    /**
-     * @see PlatformManagerImpl#showInFinder(java.io.File)
-     */
-    protected boolean showInFinder(File path, String fb) {return false;}
-
-    /**
-     * <p>Gets whether the invocation bridge is available for use</p>
-     * <p>This method is used to anticipate scenarios such as where the bridge will fail due to missing classpaths</p>
-     */
-    protected abstract boolean isEnabled();
-
-    /**
-     * Disposes system resources
-     */
-    protected void dispose(){}
-
-    /**
-     * A NativeInvocationBridge that does nothing; isEnabled() always returns false.
-     */
-    private static class DummyBridge extends NativeInvocationBridge
-    {
-        public boolean isEnabled()
-        {
-            return false;
-        }
-    }
-}
diff -urN org/gudy/azureus2/platform.orig/macosx/PlatformManagerImpl.java org/gudy/azureus2/platform/macosx/PlatformManagerImpl.java
--- org/gudy/azureus2/platform.orig/macosx/PlatformManagerImpl.java	2008-10-10 11:34:04.000000000 -0700
+++ org/gudy/azureus2/platform/macosx/PlatformManagerImpl.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,808 +0,0 @@
-/*
- * Created on 13-Mar-2004
- * Created by James Yeh
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.macosx;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.InetAddress;
-import java.text.MessageFormat;
-import java.util.HashSet;
-
-import org.gudy.azureus2.core3.config.COConfigurationManager;
-import org.gudy.azureus2.core3.config.ParameterListener;
-import org.gudy.azureus2.core3.logging.LogAlert;
-import org.gudy.azureus2.core3.logging.LogEvent;
-import org.gudy.azureus2.core3.logging.LogIDs;
-import org.gudy.azureus2.core3.logging.Logger;
-import org.gudy.azureus2.core3.util.AEDiagnostics;
-import org.gudy.azureus2.core3.util.AEDiagnosticsEvidenceGenerator;
-import org.gudy.azureus2.core3.util.AEMonitor;
-import org.gudy.azureus2.core3.util.Constants;
-import org.gudy.azureus2.core3.util.Debug;
-import org.gudy.azureus2.core3.util.IndentWriter;
-import org.gudy.azureus2.core3.util.SystemProperties;
-import org.gudy.azureus2.platform.PlatformManager;
-import org.gudy.azureus2.platform.PlatformManagerCapabilities;
-import org.gudy.azureus2.platform.PlatformManagerListener;
-import org.gudy.azureus2.platform.PlatformManagerPingCallback;
-import org.gudy.azureus2.platform.macosx.access.jnilib.OSXAccess;
-import org.gudy.azureus2.plugins.platform.PlatformManagerException;
-
-import com.apple.cocoa.application.NSApplication;
-
-
-/**
- * Performs platform-specific operations with Mac OS X
- *
- * @author James Yeh
- * @version 1.0 Initial Version
- * @see PlatformManager
- */
-public class PlatformManagerImpl implements PlatformManager, AEDiagnosticsEvidenceGenerator
-{
-    private static final LogIDs LOGID = LogIDs.CORE;
-
-    protected static PlatformManagerImpl singleton;
-    protected static AEMonitor class_mon = new AEMonitor("PlatformManager");
-    
-    private static String fileBrowserName = "Finder";
-
-    //T: PlatformManagerCapabilities
-    private final HashSet capabilitySet = new HashSet();
-
-    /**
-     * Gets the platform manager singleton, which was already initialized
-     */
-    public static PlatformManagerImpl getSingleton()
-    {
-        return singleton;
-    }
-
-    /**
-     * Tries to enable cocoa-java access and instantiates the singleton
-     */
-    static
-    {
-        initializeSingleton();
-    }
-
-    /**
-     * Instantiates the singleton
-     */
-    private static void initializeSingleton()
-    {
-        try
-        {
-            class_mon.enter();
-            singleton = new PlatformManagerImpl();
-        }
-        catch (Throwable e)
-        {
-        	Logger.log(new LogEvent(LOGID, "Failed to initialize platform manager"
-					+ " for Mac OS X", e));
-        }
-        finally
-        {
-            class_mon.exit();
-        }
-
-        COConfigurationManager.addAndFireParameterListener("FileBrowse.usePathFinder", new ParameterListener() {
-					public void parameterChanged(String parameterName) {
-						fileBrowserName = COConfigurationManager.getBooleanParameter("FileBrowse.usePathFinder")
-	        		? "Path Finder" : "Finder";
-					}
-				});
-    }
-
-    /**
-     * Creates a new PlatformManager and initializes its capabilities
-     */
-    public PlatformManagerImpl()
-    {
-        capabilitySet.add(PlatformManagerCapabilities.RecoverableFileDelete);
-        capabilitySet.add(PlatformManagerCapabilities.ShowFileInBrowser);
-        capabilitySet.add(PlatformManagerCapabilities.ShowPathInCommandLine);
-        capabilitySet.add(PlatformManagerCapabilities.CreateCommandLineProcess);
-        capabilitySet.add(PlatformManagerCapabilities.GetUserDataDirectory);
-        capabilitySet.add(PlatformManagerCapabilities.UseNativeScripting);
-        capabilitySet.add(PlatformManagerCapabilities.PlaySystemAlert);
-        capabilitySet.add(PlatformManagerCapabilities.RequestUserAttention);
-        
-        if (OSXAccess.isLoaded()) {
-	        capabilitySet.add(PlatformManagerCapabilities.GetVersion);
-        }
-        AEDiagnostics.addEvidenceGenerator(this);
-        
-        checkPList();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public int getPlatformType()
-    {
-        return PT_MACOSX;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public String getVersion() throws PlatformManagerException
-    {
-    	if (!OSXAccess.isLoaded()) {
-        throw new PlatformManagerException("Unsupported capability called on platform manager");
-    	}
-    	
-    	return OSXAccess.getVersion();
-    }
-
-    protected PListEditor
-    getPList()
-    
-    	throws IOException
-    {
-		String	plist = 
-			System.getProperty("user.dir") +
-			SystemProperties.SEP+ SystemProperties.getApplicationName() + ".app/Contents/Info.plist";
-
-		PListEditor editor = new PListEditor( plist );
-	
-		return( editor );
-    }
-    
-    protected void
-    checkPList()
-    {
-    	try{
-    		PListEditor editor = getPList();
-    		
-    		editor.setFileTypeExtensions(new String[] {"torrent","tor","vuze","vuz"});
-    		editor.setSimpleStringValue("CFBundleName", "Vuze");
-			editor.setSimpleStringValue("CFBundleTypeName", "Vuze Download");
-			editor.setSimpleStringValue("CFBundleGetInfoString","Vuze");
-			editor.setSimpleStringValue("CFBundleShortVersionString",Constants.AZUREUS_VERSION);
-			editor.setSimpleStringValue("CFBundleVersion",Constants.AZUREUS_VERSION);
-			editor.setArrayValues("CFBundleURLSchemes", "string", new String[] { "magnet", "dht", "vuze"});
-			
-    	}catch( Throwable e ){
-    		
-    		Debug.out( "Failed to update plist", e );
-    	}
-	
-    }
-    
-    protected void
-    touchPList()
-    {
-       	try{
-    		PListEditor editor = getPList();
-  	
-    		editor.touchFile();
-    		
-       	}catch( Throwable e ){
-    		
-    		Debug.out( "Failed to touch plist", e );
-    	}
-    }
-    
-    /**
-     * {@inheritDoc}
-     * @see org.gudy.azureus2.core3.util.SystemProperties#getUserPath()
-     */
-    public String getUserDataDirectory() throws PlatformManagerException
-    {
-    	return new File(System.getProperty("user.home")
-    			+ "/Library/Application Support/" 
-    			+ SystemProperties.APPLICATION_NAME).getPath()
-    			+ SystemProperties.SEP;
-    }
-
-	public File
-	getLocation(
-		long	location_id )
-	
-		throws PlatformManagerException
-	{
-		switch ((int)location_id) {
-			case LOC_USER_DATA:
-				return new File(getUserDataDirectory());
-				
-			case LOC_DOCUMENTS:
-				try {
-					return new File(OSXAccess.getDocDir());
-				} catch (Throwable e) {
-					// throws UnsatisfiedLinkError if no osxaccess
-					// Sometimes throws NullPointerException
-
-					// Usually in user.home + Documents
-					return new File(System.getProperty("user.home"), "Documents");
-				}
-				
-			case LOC_MUSIC:
-				
-			case LOC_VIDEO:
-
-			default:
-				return( null );
-		}
-		
-	}
-    /**
-     * Not implemented; returns True
-     */
-    public boolean isApplicationRegistered() throws PlatformManagerException
-    {
-        return true;
-    }
-
-    
-	public String
-	getApplicationCommandLine()
-		throws PlatformManagerException
-	{
-		try{	    
-			String	bundle_path = System.getProperty("user.dir") +SystemProperties.SEP+ SystemProperties.getApplicationName() + ".app";
-
-			File osx_app_bundle = new File( bundle_path ).getAbsoluteFile();
-			
-			if( !osx_app_bundle.exists() ) {
-				String msg = "OSX app bundle not found: [" +osx_app_bundle.toString()+ "]";
-				System.out.println( msg );
-				if (Logger.isEnabled())
-					Logger.log(new LogEvent(LOGID, msg));		
-				throw new PlatformManagerException( msg );
-			}
-			
-			return "open -a \"" +osx_app_bundle.toString()+ "\"";
-			//return osx_app_bundle.toString() +"/Contents/MacOS/JavaApplicationStub";
-			
-		}
-		catch( Throwable t ){	
-			t.printStackTrace();
-			return null;
-		}
-	}
-	
-	
-	public boolean
-	isAdditionalFileTypeRegistered(
-		String		name,				// e.g. "BitTorrent"
-		String		type )				// e.g. ".torrent"
-	
-		throws PlatformManagerException
-	{
-	    throw new PlatformManagerException("Unsupported capability called on platform manager");
-	}
-	
-	public void
-	unregisterAdditionalFileType(
-		String		name,				// e.g. "BitTorrent"
-		String		type )				// e.g. ".torrent"
-		
-		throws PlatformManagerException
-	{
-		throw new PlatformManagerException("Unsupported capability called on platform manager");
-	}
-	
-	public void
-	registerAdditionalFileType(
-		String		name,				// e.g. "BitTorrent"
-		String		description,		// e.g. "BitTorrent File"
-		String		type,				// e.g. ".torrent"
-		String		content_type )		// e.g. "application/x-bittorrent"
-	
-		throws PlatformManagerException
-	{
-	   throw new PlatformManagerException("Unsupported capability called on platform manager");
-	}
-	
-    public void registerApplication() throws PlatformManagerException
-    {
-    	touchPList();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void createProcess(String cmd, boolean inheritsHandles) throws PlatformManagerException
-    {
-        try
-        {
-            performRuntimeExec(cmd.split(" "));
-        }
-        catch (Throwable e)
-        {
-            throw new PlatformManagerException("Failed to create process", e);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void performRecoverableFileDelete(String path) throws PlatformManagerException
-    {
-        File file = new File(path);
-        if(!file.exists())
-        {
-	        	if (Logger.isEnabled())
-							Logger.log(new LogEvent(LOGID, LogEvent.LT_WARNING, "Cannot find "
-									+ file.getName()));
-            return;
-        }
-
-        boolean useOSA = !NativeInvocationBridge.sharedInstance().isEnabled() || !NativeInvocationBridge.sharedInstance().performRecoverableFileDelete(file);
-
-        if(useOSA)
-        {
-            try
-            {
-                StringBuffer sb = new StringBuffer();
-                sb.append("tell application \"");
-                sb.append("Finder");
-                sb.append("\" to move (posix file \"");
-                sb.append(path);
-                sb.append("\" as alias) to the trash");
-
-                performOSAScript(sb);
-            }
-            catch (Throwable e)
-            {
-                throw new PlatformManagerException("Failed to move file", e);
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean hasCapability(PlatformManagerCapabilities capability)
-    {
-        return capabilitySet.contains(capability);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void dispose()
-    {
-        NativeInvocationBridge.sharedInstance().dispose();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void setTCPTOSEnabled(boolean enabled) throws PlatformManagerException
-    {
-        throw new PlatformManagerException("Unsupported capability called on platform manager");
-    }
-
-	public void
-    copyFilePermissions(
-		String	from_file_name,
-		String	to_file_name )
-	
-		throws PlatformManagerException
-	{
-	    throw new PlatformManagerException("Unsupported capability called on platform manager");		
-	}
-	
-    /**
-     * {@inheritDoc}
-     */
-    public void showFile(String path) throws PlatformManagerException
-    {
-        File file = new File(path);
-        if(!file.exists())
-        {
-        	if (Logger.isEnabled())
-        		Logger.log(new LogEvent(LOGID, LogEvent.LT_WARNING, "Cannot find "
-        				+ file.getName()));
-            throw new PlatformManagerException("File not found");
-        }
-
-        showInFinder(file);
-    }
-
-    // Public utility methods not shared across the interface
-
-    /**
-     * Plays the system alert (the jingle is specified by the user in System Preferences)
-     */
-    public void playSystemAlert()
-    {
-        try
-        {
-            performRuntimeExec(new String[]{"beep"});
-        }
-        catch (IOException e)
-        {
-        	if (Logger.isEnabled())
-        		Logger.log(new LogEvent(LOGID, LogEvent.LT_WARNING,
-						"Cannot play system alert"));
-        	Logger.log(new LogEvent(LOGID, "", e));
-        }
-    }
-
-    /**
-     * <p>Shows the given file or directory in Finder</p>
-     * @param path Absolute path to the file or directory
-     */
-    public void showInFinder(File path)
-    {
-        boolean useOSA = !NativeInvocationBridge.sharedInstance().isEnabled() || !NativeInvocationBridge.sharedInstance().showInFinder(path,fileBrowserName);
-
-        if(useOSA)
-        {
-            StringBuffer sb = new StringBuffer();
-            sb.append("tell application \"");
-            sb.append(getFileBrowserName());
-            sb.append("\" to reveal (posix file \"");
-            sb.append(path);
-            sb.append("\" as alias)");
-
-            try
-            {
-                performOSAScript(sb);
-            }
-            catch (IOException e)
-            {
-                Logger.log(new LogAlert(LogAlert.UNREPEATABLE, LogAlert.AT_ERROR, e
-						.getMessage()));
-            }
-        }
-    }
-
-    /**
-     * <p>Shows the given file or directory in Terminal by executing cd /absolute/path/to</p>
-     * @param path Absolute path to the file or directory
-     */
-    public void showInTerminal(String path)
-    {
-        showInTerminal(new File(path));
-    }
-
-    /**
-     * <p>Shows the given file or directory in Terminal by executing cd /absolute/path/to</p>
-     * @param path Absolute path to the file or directory
-     */
-    public void showInTerminal(File path)
-    {
-        if (path.isFile())
-        {
-            path = path.getParentFile();
-        }
-
-        if (path != null && path.isDirectory())
-        {
-            StringBuffer sb = new StringBuffer();
-            sb.append("tell application \"");
-            sb.append("Terminal");
-            sb.append("\" to do script \"cd ");
-            sb.append(path.getAbsolutePath().replaceAll(" ", "\\ "));
-            sb.append("\"");
-
-            try
-            {
-                performOSAScript(sb);
-            }
-            catch (IOException e)
-            {
-                Logger.log(new LogAlert(LogAlert.UNREPEATABLE, LogAlert.AT_ERROR, e
-						.getMessage()));
-            }
-        }
-        else
-        {
-        	if (Logger.isEnabled())
-        		Logger.log(new LogEvent(LOGID, LogEvent.LT_WARNING, "Cannot find "
-        				+ path.getName()));
-        }
-    }
-
-    // Internal utility methods
-
-    /**
-     * Compiles a new AppleScript instance and runs it
-     * @param cmd AppleScript command to execute; do not surround command with extra quotation marks
-     * @return Output of the script
-     * @throws IOException If the script failed to execute
-     */
-    protected static String performOSAScript(CharSequence cmd) throws IOException
-    {
-        return performOSAScript(new CharSequence[]{cmd});
-    }
-
-    /**
-     * Compiles a new AppleScript instance and runs it
-     * @param cmds AppleScript Sequence of commands to execute; do not surround command with extra quotation marks
-     * @return Output of the script
-     * @throws IOException If the script failed to execute
-     */
-    protected static String performOSAScript(CharSequence[] cmds) throws IOException
-    {
-        long start = System.currentTimeMillis();
-        Debug.outNoStack("Executing OSAScript: ");
-        for (int i = 0; i < cmds.length; i++)
-        {
-            Debug.outNoStack("\t" + cmds[i]);
-        }
-
-        String[] cmdargs = new String[2 * cmds.length + 1];
-        cmdargs[0] = "osascript";
-        for (int i = 0; i < cmds.length; i++)
-        {
-            cmdargs[i * 2 + 1] = "-e";
-            cmdargs[i * 2 + 2] = String.valueOf(cmds[i]);
-        }
-
-        Process osaProcess = performRuntimeExec(cmdargs);
-        BufferedReader reader = new BufferedReader(new InputStreamReader(osaProcess.getInputStream()));
-        String line = reader.readLine();
-        reader.close();
-        Debug.outNoStack("OSAScript Output: " + line);
-
-        reader = new BufferedReader(new InputStreamReader(osaProcess.getErrorStream()));
-        String errorMsg = reader.readLine();
-        reader.close();
-
-        Debug.outNoStack("OSAScript Error (if any): " + errorMsg);
-
-        Debug.outNoStack(MessageFormat.format("OSAScript execution ended ({0}ms)", new Object[]{String.valueOf(System.currentTimeMillis() - start)}));
-
-        try {
-        	osaProcess.destroy();
-        } catch (Throwable t) {
-        	//ignore
-        }
-
-        if (errorMsg != null)
-        {
-            throw new IOException(errorMsg);
-        }
-
-        return line;
-    }
-
-    /**
-     * Compiles a new AppleScript instance and runs it
-     * @param script AppleScript file (.scpt) to execute
-     * @return Output of the script
-     * @throws IOException If the script failed to execute
-     */
-    protected static String performOSAScript(File script) throws IOException
-    {
-        long start = System.currentTimeMillis();
-        Debug.outNoStack("Executing OSAScript from file: " + script.getPath());
-
-        Process osaProcess = performRuntimeExec(new String[]{"osascript", script.getPath()});
-        BufferedReader reader = new BufferedReader(new InputStreamReader(osaProcess.getInputStream()));
-        String line = reader.readLine();
-        reader.close();
-        Debug.outNoStack("OSAScript Output: " + line);
-
-        reader = new BufferedReader(new InputStreamReader(osaProcess.getErrorStream()));
-        String errorMsg = reader.readLine();
-        reader.close();
-
-        Debug.outNoStack("OSAScript Error (if any): " + errorMsg);
-
-        Debug.outNoStack(MessageFormat.format("OSAScript execution ended ({0}ms)", new Object[]{String.valueOf(System.currentTimeMillis() - start)}));
-
-        try {
-        	osaProcess.destroy();
-        } catch (Throwable t) {
-        	//ignore
-        }
-        if (errorMsg != null)
-        {
-            throw new IOException(errorMsg);
-        }
-
-        return line;
-    }
-
-    /**
-     * Compiles a new AppleScript instance to the specified location
-     * @param cmd         Command to compile; do not surround command with extra quotation marks
-     * @param destination Destination location of the AppleScript file
-     * @return True if compiled successfully
-     */
-    protected static boolean compileOSAScript(CharSequence cmd, File destination)
-    {
-        return compileOSAScript(new CharSequence[]{cmd}, destination);
-    }
-
-    /**
-     * Compiles a new AppleScript instance to the specified location
-     * @param cmds Sequence of commands to compile; do not surround command with extra quotation marks
-     * @param destination Destination location of the AppleScript file
-     * @return True if compiled successfully
-     */
-    protected static boolean compileOSAScript(CharSequence[] cmds, File destination)
-    {
-        long start = System.currentTimeMillis();
-        Debug.outNoStack("Compiling OSAScript: " + destination.getPath());
-        for (int i = 0; i < cmds.length; i++)
-        {
-            Debug.outNoStack("\t" + cmds[i]);
-        }
-
-        String[] cmdargs = new String[2 * cmds.length + 3];
-        cmdargs[0] = "osacompile";
-        for (int i = 0; i < cmds.length; i++)
-        {
-            cmdargs[i * 2 + 1] = "-e";
-            cmdargs[i * 2 + 2] = String.valueOf(cmds[i]);
-        }
-
-        cmdargs[cmdargs.length - 2] = "-o";
-        cmdargs[cmdargs.length - 1] = destination.getPath();
-
-        String errorMsg;
-        try
-        {
-            Process osaProcess = performRuntimeExec(cmdargs);
-
-            BufferedReader reader = new BufferedReader(new InputStreamReader(osaProcess.getErrorStream()));
-            errorMsg = reader.readLine();
-            reader.close();
-        }
-        catch (IOException e)
-        {
-            Debug.outNoStack("OSACompile Execution Failed: " + e.getMessage());
-            Debug.printStackTrace(e);
-            return false;
-        }
-
-        Debug.outNoStack("OSACompile Error (if any): " + errorMsg);
-
-        Debug.outNoStack(MessageFormat.format("OSACompile execution ended ({0}ms)", new Object[]{String.valueOf(System.currentTimeMillis() - start)}));
-
-        return (errorMsg == null);
-    }
-
-    /**
-     * @see Runtime#exec(String[])
-     */
-    protected static Process performRuntimeExec(String[] cmdargs) throws IOException
-    {
-        try
-        {
-            return Runtime.getRuntime().exec(cmdargs);
-        }
-        catch (IOException e)
-        {
-            Logger.log(new LogAlert(LogAlert.UNREPEATABLE, e.getMessage(), e));
-            throw e;
-        }
-    }
-
-    /**
-     * <p>Gets the preferred file browser name</p>
-     * <p>Currently supported browsers are Path Finder and Finder. If Path Finder is currently running
-     * (not just installed), then "Path Finder is returned; else, "Finder" is returned.</p>
-     * @return "Path Finder" if it is currently running; else "Finder"
-     */
-    private static String getFileBrowserName()
-    {
-    	return fileBrowserName;
-    }
-    
-	public boolean
-	testNativeAvailability(
-		String	name )
-	
-		throws PlatformManagerException
-	{
-	    throw new PlatformManagerException("Unsupported capability called on platform manager");		
-	}
-    
-	public void
-	traceRoute(
-		InetAddress							interface_address,
-		InetAddress							target,
-		PlatformManagerPingCallback			callback )
-	
-		throws PlatformManagerException
-	{
-	    throw new PlatformManagerException("Unsupported capability called on platform manager");		
-	}
-	
-	public void
-	ping(
-		InetAddress							interface_address,
-		InetAddress							target,
-		PlatformManagerPingCallback			callback )
-	
-		throws PlatformManagerException
-	{
-	    throw new PlatformManagerException("Unsupported capability called on platform manager");		
-	}
-	
-    public void
-    addListener(
-    	PlatformManagerListener		listener )
-    {
-    }
-    
-    public void
-    removeListener(
-    	PlatformManagerListener		listener )
-    {
-    }
-
-		// @see org.gudy.azureus2.core3.util.AEDiagnosticsEvidenceGenerator#generate(org.gudy.azureus2.core3.util.IndentWriter)
-		public void generate(IndentWriter writer) {
-			writer.println("PlatformManager: MacOSX");
-			try {
-				writer.indent();
-				
-				if (OSXAccess.isLoaded()) {
-					try {
-						writer.println("Version " + getVersion());
-						writer.println("User Data Dir: " + getLocation(LOC_USER_DATA));
-						writer.println("User Doc Dir: " + getLocation(LOC_DOCUMENTS));
-					} catch (PlatformManagerException e) {
-					}
-				} else {
-					writer.println("Not loaded");
-				}
-			} finally {
-				writer.exdent();
-			}
-		}
-
-	// @see org.gudy.azureus2.platform.PlatformManager#getAzComputerID()
-	public String getAzComputerID() throws PlatformManagerException {
-		throw new PlatformManagerException(
-				"Unsupported capability called on platform manager");
-	}
-
-	/**
-	 * If the application is not active causes the application icon at the bottom to bounce until the application becomes active
-	 * If the application is already active then this method does nothing.
-	 * 
-	 * Note: This is an undocumented feature from Apple so it's behavior may change without warning
-	 * 
-	 * @param type one of USER_REQUEST_INFO, USER_REQUEST_WARNING
-	 */
-	public void requestUserAttention(int type, Object data)
-			throws PlatformManagerException {
-		try {
-			NSApplication app = NSApplication.sharedApplication();
-			if (type == USER_REQUEST_INFO) {
-				app.requestUserAttention(NSApplication.UserAttentionRequestInformational);
-			} else if (type == USER_REQUEST_WARNING) {
-				app.requestUserAttention(NSApplication.UserAttentionRequestCritical);
-			} else if (type == USER_REQUEST_QUESTION) {
-				// not applicable
-			}
-
-		} catch (Exception e) {
-			throw new PlatformManagerException("Failed to request user attention", e);
-		}
-
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/macosx/PListEditor.java org/gudy/azureus2/platform/macosx/PListEditor.java
--- org/gudy/azureus2/platform.orig/macosx/PListEditor.java	2008-08-26 08:37:44.000000000 -0700
+++ org/gudy/azureus2/platform/macosx/PListEditor.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,281 +0,0 @@
-/*
- * Created on Apr 1, 2008
- * Created by Paul Gardner
- * 
- * Copyright 2008 Vuze, Inc.  All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License only.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
- */
-
-package org.gudy.azureus2.platform.macosx;
-
-import java.io.File;
-import java.io.FileReader;
-import java.io.FileWriter;
-import java.io.IOException;
-
-import org.gudy.azureus2.core3.util.FileUtil;
-
-public class 
-PListEditor 
-{	
-	private String plistFile;
-	
-	
-	public 
-	PListEditor(
-		String plistFile )
-	
-		throws IOException
-	{
-		this.plistFile = plistFile;
-		
-		File	file  = new File( plistFile );
-		
-		if ( !file.exists()){
-			
-			throw( new IOException( "plist file '" + file + "' doesn't exist" ));
-		}
-		
-		if ( !file.canWrite()){
-			
-			throw( new IOException( "plist file '" + file + "' is read only" ));
-		}
-	}
-	
-	public void 
-	setFileTypeExtensions(
-		String[] extensions )
-	
-		throws IOException
-	{
-		StringBuffer value = new StringBuffer();
-		StringBuffer find = new StringBuffer();
-		find.append("(?s).*?<key>CFBundleDocumentTypes</key>\\s*<array>.*?<key>CFBundleTypeExtensions</key>\\s*<array>");
-		for(int i = 0 ; i < extensions.length ; i++) {
-			value.append("\n\t\t\t\t<string>");
-			value.append(extensions[i]);
-			value.append("</string>");
-			
-			find.append(".*?");
-			find.append(extensions[i]);
-		}
-		value.append("\n\t\t\t");
-		
-		find.append(".*?</array>.*");
-		String match = "(?s)(<key>CFBundleDocumentTypes</key>\\s*<array>.*?<key>CFBundleTypeExtensions</key>\\s*<array>)(.*?)(</array>)";
-		
-		setValue(find.toString(), match, value.toString());
-	}
-	
-	public void 
-	setSimpleStringValue(
-		String key,
-		String value)
-	
-		throws IOException
-	{
-		String find = "(?s).*?<key>" + key + "</key>\\s*" + "<string>" + value + "</string>.*";
-		String match = "(?s)(<key>" + key + "</key>\\s*" + "<string>)(.*?)(</string>)";
-		setValue(find, match, value);
-	}
-	
-	public void
-	setArrayValues(
-		String key,
-		String valueType,
-		String[] values) 
-	
-		throws IOException
-	{
-		StringBuffer value = new StringBuffer();
-		StringBuffer find = new StringBuffer();
-		find.append("(?s).*?<key>" + key + "</key>\\s*" + "<array>");
-		for(int i = 0 ; i < values.length ; i++) {
-			find.append("\\s*<" + valueType + ">" + values[i] + "</" + valueType + ">");
-			value.append("\n\t\t\t\t<" + valueType + ">");
-			value.append(values[i]);
-			value.append("</" + valueType + ">");
-		}
-		find.append("\\s*</array>.*");
-		value.append("\n\t\t\t");
-		
-		String match = "(?s)(<key>" + key + "</key>\\s*<array>)(.*?)(</array>)";
-		
-		setValue(find.toString(),match,value.toString());
-	}
-	
-	private boolean 
-	isValuePresent(
-		String match )
-	
-		throws IOException
-	{
-		String fileContent = getFileContent();
-		
-		//System.out.println("Searching for:\n" + match);
-		return fileContent.matches(match);
-	}
-	
-
-	/**
-	 * 
-	 * @param find the regex expression to find if the value is already present
-	 * @param match the regex expression that will match for the replace, it needs to capture 3 groups, the 2nd one being replaced by value
-	 * @param value the value that replaces the 2nd match group
-	 */
-	private void 
-	setValue(
-		String find,
-		String match,
-		String value)
-	
-		throws IOException
-	{
-		String fileContent = getFileContent();
-		
-		if( !isValuePresent(find)) {
-			//System.out.println("Changing " +plistFile);
-			fileContent = fileContent.replaceFirst(match, "$1"+value + "$3");
-			setFileContent(fileContent);
-			touchFile();
-		}
-	}
-	
-	private String 
-	getFileContent()
-		throws IOException
-	{
-		FileReader fr = null;
-		
-		try{
-			fr = new FileReader(plistFile);
-			//max 32KB
-			int length = 32 * 1024;
-			char[] buffer = new char[length];
-			int offset = 0;
-			int len = 0;
-			
-			while((len = fr.read(buffer,offset,length-offset)) > 0) {
-				offset += len;
-			}
-			
-			String result =  new String(buffer,0,offset);
-			
-			return result;
-			
-		} finally {
-			if(fr != null) {
-				fr.close();
-			}
-		}
-		
-		
-		//return FileUtil.readFileAsString(new File(plistFile), 64*1024, "UTF-8" );
-	}
-	
-	private void 
-	setFileContent(
-		String fileContent )
-	
-		throws IOException
-	{
-		File	file		= new File( plistFile );
-		
-		File	backup_file = new File( plistFile + ".bak" );
-		
-		if ( file.exists()){
-			
-			if ( !FileUtil.copyFile( file, backup_file )){
-				
-				throw( new IOException( "Failed to backup plist file prior to modification" ));
-			}
-		}
-		
-		boolean	ok = false;
-		
-		try{
-			
-			FileWriter fw = null;
-			
-			try{
-				
-				fw = new FileWriter(plistFile);
-				fw.write(fileContent);
-	
-			} finally {
-				
-				if( fw != null ){
-					
-					fw.close();
-					
-					ok = true;
-				}
-			}
-		}finally{
-			if ( ok ){
-				
-				backup_file.delete();
-				
-			}else{
-				
-				if ( backup_file.exists()){
-					
-					File	bork_file = new File( plistFile + ".bad" );
-
-					file.renameTo( bork_file );
-					
-					file.delete();
-					
-					backup_file.renameTo( file );
-				}
-			}
-		}
-	}
-	
-	public void 
-	touchFile()
-	{
-		File	file  = new File( plistFile );
-		for(int i = 0 ; i <= 2 ; i++) {
-			if(file != null) {
-				String command[] = new String[] { "touch", file.getAbsolutePath() };
-				
-				try{
-					Runtime.getRuntime().exec(command);
-					
-				} catch(Exception e) {
-					
-					e.printStackTrace();
-				}
-			}
-			file = file.getParentFile();
-		}
-	}
-	
-	public static void main(String args[]) {
-		try{
-			PListEditor editor = new PListEditor("/Applications/Vuze.app/Contents/Info.plist");
-			editor.setFileTypeExtensions(new String[] {"torrent","tor","vuze","vuz"});
-			editor.setSimpleStringValue("CFBundleName", "Vuze");
-			editor.setSimpleStringValue("CFBundleTypeName", "Vuze Download");
-			editor.setSimpleStringValue("CFBundleGetInfoString","Vuze");
-			editor.setArrayValues("CFBundleURLSchemes", "string", new String[] {"magnet","dht"});
-		}catch( Throwable e ){
-			
-			e.printStackTrace();
-		}
-	}
-
-}
diff -urN org/gudy/azureus2/platform.orig/PlatformManagerFactory.java org/gudy/azureus2/platform/PlatformManagerFactory.java
--- org/gudy/azureus2/platform.orig/PlatformManagerFactory.java	2007-01-12 12:39:24.000000000 -0800
+++ org/gudy/azureus2/platform/PlatformManagerFactory.java	2008-12-19 23:42:17.000000000 -0800
@@ -46,15 +46,8 @@
 			if ( platform_manager == null ){
 										  
 				try{
-					if ( getPlatformType() == PlatformManager.PT_WINDOWS ){
-						
-						platform_manager = org.gudy.azureus2.platform.win32.PlatformManagerImpl.getSingleton();
-						
-					}else if( getPlatformType() == PlatformManager.PT_MACOSX ){
-						
-	                    platform_manager = org.gudy.azureus2.platform.macosx.PlatformManagerImpl.getSingleton();
 	                    
-					}else if( getPlatformType() == PlatformManager.PT_UNIX ){
+					if( getPlatformType() == PlatformManager.PT_UNIX ){
 						
             platform_manager = org.gudy.azureus2.platform.unix.PlatformManagerImpl.getSingleton();
 
diff -urN org/gudy/azureus2/platform.orig/PlatformManagerPluginDelegate.java org/gudy/azureus2/platform/PlatformManagerPluginDelegate.java
--- org/gudy/azureus2/platform.orig/PlatformManagerPluginDelegate.java	2007-07-25 12:02:00.000000000 -0700
+++ org/gudy/azureus2/platform/PlatformManagerPluginDelegate.java	2008-12-19 23:44:35.000000000 -0800
@@ -23,7 +23,7 @@
 import java.util.Properties;
 
 import org.gudy.azureus2.platform.unix.PlatformManagerUnixPlugin;
-import org.gudy.azureus2.platform.win32.PlatformManagerUpdateChecker;
+//import org.gudy.azureus2.platform.win32.PlatformManagerUpdateChecker;
 
 import org.gudy.azureus2.plugins.Plugin;
 import org.gudy.azureus2.plugins.PluginException;
@@ -45,10 +45,7 @@
 		PlatformManager platform = PlatformManagerFactory.getPlatformManager();
 
 		int platformType = platform.getPlatformType();
-		if (platformType == PlatformManager.PT_WINDOWS) {
-			PlatformManagerUpdateChecker plugin = new PlatformManagerUpdateChecker();
-			plugin.initialize(pluginInterface);
-		} else if (platformType == PlatformManager.PT_UNIX) {
+		if (platformType == PlatformManager.PT_UNIX) {
 			PlatformManagerUnixPlugin plugin = new PlatformManagerUnixPlugin();
 			plugin.initialize(pluginInterface);
 		} else {
diff -urN org/gudy/azureus2/platform.orig/win32/access/AEWin32AccessException.java org/gudy/azureus2/platform/win32/access/AEWin32AccessException.java
--- org/gudy/azureus2/platform.orig/win32/access/AEWin32AccessException.java	2008-05-14 15:08:04.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/AEWin32AccessException.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,40 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access;
-
-/**
- * @author parg
- *
- */
-public class 
-AEWin32AccessException
-	extends Exception
-{
-	
-	public
-	AEWin32AccessException(
-		String	str )
-	{
-		super( str );
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/AEWin32Access.java org/gudy/azureus2/platform/win32/access/AEWin32Access.java
--- org/gudy/azureus2/platform.orig/win32/access/AEWin32Access.java	2008-07-08 18:45:46.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/AEWin32Access.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,229 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access;
-
-import java.net.InetAddress;
-
-import org.gudy.azureus2.platform.PlatformManagerPingCallback;
-
-/**
- * @author parg
- *
- */
-
-
-public interface 
-AEWin32Access 
-{
-	public static final int	HKEY_CLASSES_ROOT		= 1;
-	public static final int	HKEY_CURRENT_CONFIG		= 2;
-	public static final int	HKEY_LOCAL_MACHINE		= 3;
-	public static final int	HKEY_CURRENT_USER		= 4;
-	
-	public static final int SW_HIDE = 0;
-	public static final int SW_NORMAL = 1;
-	public static final int SW_SHOWNORMAL = 1;
-	public static final int SW_SHOWMINIMIZED = 2;
-	public static final int SW_SHOWMAXIMIZED = 3;
-	public static final int SW_MAXIMIZE = 3;
-	public static final int SW_SHOWNOACTIVATE = 4;
-	public static final int SW_SHOW = 5;
-	public static final int SW_MINIMIZE = 6;
-	public static final int SW_SHOWMINNOACTIVE = 7;
-	public static final int SW_SHOWNA = 8;
-	public static final int SW_RESTORE = 9;
-	public static final int SW_SHOWDEFAULT = 10;
-	public static final int SW_FORCEMINIMIZE = 11;
-	public static final int SW_MAX = 11;
-
-	public boolean
-	isEnabled();
-	
-	public String
-	getVersion();
-	
-	public String
-	readStringValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	writeStringValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name,
-		String	value_value )
-	
-		throws AEWin32AccessException;
-	
-	public int
-	readWordValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	writeWordValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name,
-		int		value_value )
-	
-		throws AEWin32AccessException;
-	
-
-	public void
-	deleteKey(
-		int		type,
-		String	subkey )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	deleteKey(
-		int			type,
-		String		subkey,
-		boolean		recursuve )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	deleteValue(
-		int			type,
-		String		subkey,
-		String		value_name )
-	
-		throws AEWin32AccessException;
-	
-	public String
-	getUserAppData()
-	
-		throws AEWin32AccessException;
-	
-	public String
-	getProgramFilesDir()
-	
-		throws AEWin32AccessException;
-	
-	public String
-	getApplicationInstallDir(
-		String	app_name )
-		
-		throws AEWin32AccessException;
-	
-	public void
-	createProcess(
-		String		command_line,
-		boolean		inherit_handles )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	moveToRecycleBin(
-		String	file_name )
-	
-		throws AEWin32AccessException;
-	
-	public void
-    copyFilePermissions(
-		String	from_file_name,
-		String	to_file_name )
-	
-		throws AEWin32AccessException;
-	
-	public boolean
-	testNativeAvailability(
-		String	name )
-		
-		throws AEWin32AccessException;
-	
-	public void
-	traceRoute(
-		InetAddress							source_address,
-		InetAddress							target_address,
-		PlatformManagerPingCallback	callback )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	ping(
-		InetAddress							source_address,
-		InetAddress							target_address,
-		PlatformManagerPingCallback	callback )
-	
-		throws AEWin32AccessException;
-	
-	public void
-	addListener(
-		AEWin32AccessListener	listener );
-	
-	public void
-	removeListener(
-		AEWin32AccessListener	listener );
-
-	/**
-	 * @return
-	 * @throws AEWin32AccessException
-	 */
-	String getUserDocumentsDir() throws AEWin32AccessException;
-
-	/**
-	 * @return
-	 * @throws AEWin32AccessException
-	 */
-	String getUserMusicDir() throws AEWin32AccessException;
-
-	/**
-	 * @return
-	 * @throws AEWin32AccessException
-	 */
-	String getUserVideoDir() throws AEWin32AccessException;
-
-	/**
-	 * @return
-	 * @throws AEWin32AccessException
-	 */
-	String getCommonAppData() throws AEWin32AccessException;
-	
-	public int
-	shellExecute(
-		String operation, 
-		String file, 
-		String parameters, 
-		String directory, 
-		int SW_const)
-
-		throws AEWin32AccessException;
-	
-	public int
-	shellExecuteAndWait(
-		String		file,
-		String		params )
-
-		throws AEWin32AccessException;
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/AEWin32AccessListener.java org/gudy/azureus2/platform/win32/access/AEWin32AccessListener.java
--- org/gudy/azureus2/platform.orig/win32/access/AEWin32AccessListener.java	2007-07-30 19:38:58.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/AEWin32AccessListener.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,35 +0,0 @@
-/*
- * Created on 30-Jan-2006
- * Created by Paul Gardner
- * Copyright (C) 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access;
-
-public interface 
-AEWin32AccessListener 
-{
-	public static final int ET_SHUTDOWN		= 0x0001;
-	public static final int ET_SUSPEND		= 0x0002;
-	public static final int ET_RESUME		= 0x0003;
-	
-	public void
-	eventOccurred(
-		int		type );
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/AEWin32Manager.java org/gudy/azureus2/platform/win32/access/AEWin32Manager.java
--- org/gudy/azureus2/platform.orig/win32/access/AEWin32Manager.java	2006-06-13 07:04:30.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/AEWin32Manager.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,41 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access;
-
-/**
- * @author parg
- *
- */
-
-import org.gudy.azureus2.platform.win32.access.impl.*;
-
-public class 
-AEWin32Manager 
-{
-	public static AEWin32Access
-	getAccessor(
-		boolean fully_initialise )
-	{
-		return( AEWin32AccessImpl.getSingleton( fully_initialise ));
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/aenet.cpp org/gudy/azureus2/platform/win32/access/impl/aenet.cpp
--- org/gudy/azureus2/platform.orig/win32/access/impl/aenet.cpp	2008-02-07 15:38:44.000000000 -0800
+++ org/gudy/azureus2/platform/win32/access/impl/aenet.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,781 +0,0 @@
-/*
- * Created on 1 Nov 2006
- * Created by Paul Gardner
- * Copyright (C) 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 63.529,40 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-
-#include "stdafx.h"
-
-#include "stdio.h"
-#include "stdlib.h"
-#include "windows.h"
-#include "time.h"
-#include "winsock2.h"
-#include "WS2TCPIP.H"
-
-#include "aereg.h"
-#include "aenet.h"
-
-#include "org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h"
-
-
-// IP	ftp://ftp.rfc-editor.org/in-notes/rfc791.txt
-// ICMP	ftp://ftp.rfc-editor.org/in-notes/rfc792.txt
-// UDP  ftp://ftp.rfc-editor.org/in-notes/rfc768.txt	
-
-bool winsock_started_up = false;
-
-void 
-initialiseWinsock()
-{
-	if ( !winsock_started_up ){
-
-		winsock_started_up = true;
-
-		WSADATA wdData;
-
-		WSAStartup(MAKEWORD(2, 2), &wdData);
-	}
-}
-
-
-unsigned short
-calculateChecksum(
-	unsigned short const	words[], 
-	int						num_words )
-{
-    unsigned long  sum = 0;
-
-    while (num_words-- > 0){
-    
-        sum += *(words++);
-    }
-
-    sum = (sum >> 16) + (sum & 0xFFFF);
-    sum += sum >> 16;
-
-    unsigned short result =  ((unsigned short) ~sum);
-
-	if ( result == 0 ){
-
-		result = 0xffff;
-	}
-
-	return( result );
-} 
-
-unsigned short
-calculateChecksum2(
-	unsigned short const	words1[], 
-	int						num_words1,
-	unsigned short const	words2[], 
-	int						num_words2 )
-{
-    unsigned long  sum = 0;
-
-    while (num_words1-- > 0){
-    
-        sum += *(words1++);
-    }
-
-	while (num_words2-- > 0){
-    
-        sum += *(words2++);
-    }
-
-    sum = (sum >> 16) + (sum & 0xFFFF);
-    sum += sum >> 16;
-
-    unsigned short result =  ((unsigned short) ~sum);
-
-	if ( result == 0 ){
-
-		result = 0xffff;
-	}
-
-	return( result );
-} 
-
-int 
-sendTraceRouteMessage(
-	JNIEnv*			env,
-	unsigned short	trace_id,
-	int				time_to_live,
-    unsigned int	send_sock,
-	unsigned int	recv_sock,
-	unsigned long	source_ip,
-	unsigned short	source_port,
-    unsigned long	target_ip,
-	unsigned short	target_port,
-	bool			use_udp,
-	bool			use_icmp )
-{
-		// Advice is to use UDP rather than ICMP echos. However, reality is that UDP packets can be totally dropped with no ICMP response. So send both...
-
-		// UDP
-
-	if ( use_udp ){
-
-		udp_probe_packet  udp_probe;  
-		
-		struct sockaddr_in target;
-
-		memset( &target, 0, sizeof( target ));
-    
-		target.sin_family		= AF_INET;
-		target.sin_addr.s_addr	= htonl( target_ip );
-		target.sin_port			= htons( target_port );
-
-		// printf( "Sending to %lx from %lx: ip=%d,udp=%d,tot=%d\n", target_ip, source_ip, sizeof( ip_header ), sizeof( udp_header ), sizeof( probe_packet ));
-
-		memset( &udp_probe, 0, sizeof( udp_probe ));
-
-		udp_probe.ip.ip_version		= 4;
-		udp_probe.ip.ip_header_len	= sizeof( ip_header) >> 2;
-		udp_probe.ip.tos			= 0;
-		udp_probe.ip.total_len		= htons( sizeof( udp_probe_packet ));
-		udp_probe.ip.ident			= htons( trace_id );
-		udp_probe.ip.frag_and_flags = 0;
-		udp_probe.ip.ttl			= time_to_live;
-		udp_probe.ip.protocol		= IPPROTO_UDP;
-		udp_probe.ip.checksum		= 0;
-		udp_probe.ip.source_ip		= htonl( source_ip );
-		udp_probe.ip.dest_ip		= htonl( target_ip );
-
-		udp_probe.ip.checksum = calculateChecksum((unsigned short*)&udp_probe.ip, sizeof( ip_header ) / 2 );
-
-		udp_probe.udp.source_port	= htons( source_port );
-		udp_probe.udp.dest_port		= htons( target_port  );
-		udp_probe.udp.data_len		= htons( sizeof( udp_probe_packet ) - sizeof( ip_header ));
-		udp_probe.udp.checksum		= 0;
-
-		udp_probe.data			= 1234;
-
-		pseudo_udp_header	puh;
-
-		puh.source_ip	= htonl( source_ip );
-		puh.dest_ip		= htonl( target_ip );
-		puh.zero		= 0;
-		puh.protocol	= IPPROTO_UDP;
-		puh.data_len	= htons( sizeof( udp_probe_packet ) - sizeof( ip_header ));
-
-		udp_probe.udp.checksum = calculateChecksum2( (unsigned short*)&puh, sizeof( pseudo_udp_header ) / 2, (unsigned short *)&udp_probe.udp, (sizeof( udp_probe ) - sizeof( ip_header ))/2);
-
-
-
-		
-		/*
-		char* bytes = (char *)&probe;
-
-		for (int i=0;i<sizeof( probe );i++ ){
-
-			printf( "%x\n", bytes[i] & 0xff );
-		}
-		printf( "\n" );
-		*/
-			// whereto = to, contains sin_addr and sin_family
-
-		int	num_sent = sendto(send_sock, (char *)&udp_probe, sizeof( udp_probe ), 0, (struct sockaddr *)&target, sizeof(target));
-
-		if ( num_sent == sizeof( udp_probe ) ){
-
-			if ( !use_icmp ){
-
-				return( 1 );
-			}
-
-		}else if ( num_sent == SOCKET_ERROR ){
-
-			throwException( env, "sendto", "UDP operation failed", WSAGetLastError());
-
-			return 0;
-
-		}else{
-
-			throwException( env, "sendto", "UDP incomplete packet sent" );
-
-			return 0;
-
-		}
-	}
-
-		// ICMP
-
-	if ( use_icmp ){
-
-		icmp_probe_packet  icmp_probe;  
-		
-		struct sockaddr_in target;
-
-		memset( &target, 0, sizeof( target ));
-    
-		target.sin_family		= AF_INET;
-		target.sin_addr.s_addr	= htonl( target_ip );
-		target.sin_port			= htons( target_port );
-
-		// printf( "Sending to %lx from %lx: ip=%d,udp=%d,tot=%d\n", target_ip, source_ip, sizeof( ip_header ), sizeof( udp_header ), sizeof( probe_packet ));
-
-		memset( &icmp_probe, 0, sizeof( icmp_probe ));
-
-		icmp_probe.ip.ip_version		= 4;
-		icmp_probe.ip.ip_header_len	= sizeof( ip_header) >> 2;
-		icmp_probe.ip.tos			= 0;
-		icmp_probe.ip.total_len		= htons( sizeof( icmp_probe_packet ));
-		icmp_probe.ip.ident			= htons( trace_id );
-		icmp_probe.ip.frag_and_flags = 0;
-		icmp_probe.ip.ttl			= time_to_live;
-		icmp_probe.ip.protocol		= IPPROTO_ICMP;
-		icmp_probe.ip.checksum		= 0;
-		icmp_probe.ip.source_ip		= htonl( source_ip );
-		icmp_probe.ip.dest_ip		= htonl( target_ip );
-
-		icmp_probe.ip.checksum = calculateChecksum((unsigned short*)&icmp_probe.ip, sizeof( ip_header ) / 2 );
-
-		icmp_probe.icmp.type		= ICMP_TYPE_ECHO;
-		icmp_probe.icmp.code		= 0;
-		icmp_probe.icmp.checksum	= 0;
-		icmp_probe.icmp.ident		= htons( trace_id );
-		icmp_probe.icmp.sequence	= htons( target_port );
-
-
-		icmp_probe.icmp.checksum = calculateChecksum( (unsigned short*)&icmp_probe.icmp, sizeof( icmp_echo_header ) / 2 );
-
-
-
-		/*
-		char* bytes = (char *)&probe;
-
-		for (int i=0;i<sizeof( probe );i++ ){
-
-			printf( "%x\n", bytes[i] & 0xff );
-		}
-		printf( "\n" );
-		*/
-			// whereto = to, contains sin_addr and sin_family
-
-		int	num_sent = sendto(send_sock, (char *)&icmp_probe, sizeof( icmp_probe ), 0, (struct sockaddr *)&target, sizeof(target));
-
-		if ( num_sent == sizeof( icmp_probe ) ){
-
-			return 1;
-
-		}else if ( num_sent == SOCKET_ERROR ){
-
-			throwException( env, "sendto", "UDP operation failed", WSAGetLastError());
-
-			return 0;
-
-		}else{
-
-			throwException( env, "sendto", "UDP incomplete packet sent" );
-
-			return 0;
-
-		}
-	}
-
-	throwException( env, "sendto", "no protocol selected" );
-
-	return( 0 );
-}
-
-
-int
-traceRouteReport(
-	JNIEnv		*env,
-	jobject		callback,
-	char*		msg )
-{
-	jstring	j_msg = env->NewStringUTF( msg );
-
-	if ( j_msg == NULL ){
-
-		throwException( env, "NewStringUTF", "alloc failed" );
-
-		return 0;
-	}
-
-	int	res = 0;
-
-	jclass callback_class = env->GetObjectClass( callback );
-
-	if ( callback_class == NULL ){
-
-		throwException( env, "GetObjectClass", "failed" );
-
-		return 0;
-
-	}else{
-
-		jmethodID method = env->GetMethodID( callback_class, "generalMessage", "(Ljava/lang/String;)J");
-
-		if ( method == NULL ){
-
-			throwException( env, "GetMethodID", "method not found" );
-
-		}else{
-
-			res = (long)env->CallLongMethod( callback, method, j_msg );
-		}
-
-		env->DeleteLocalRef( callback_class );
-	}
-
-	env->ReleaseStringUTFChars( j_msg, msg );
-
-	return( res );
-}
-
-int
-traceRouteReportTimeout(
-	JNIEnv		*env,
-	jobject		callback,
-	int			ttl )
-{
-	char	buffer[1024];
-
-	sprintf( buffer, "%ld", ttl );
-
-	return( traceRouteReport( env, callback, buffer ));
-}
-
-int
-traceRouteReportResult(
-	JNIEnv			*env,
-	jobject			callback,
-	int				ttl,
-	unsigned long	address,
-	int				time,
-	bool			udp )
-{
-	char	buffer[1024];
-
-	sprintf( buffer, "%d, %ld, %d, %d", ttl, address, time, udp?1:0 );
-
-	return( traceRouteReport( env, callback, buffer ));
-}
-
-void
-traceRoute(
-	JNIEnv*			env,
-	jobject			callback,
-	unsigned short	trace_id,
-	unsigned long	source_ip,
-	unsigned long	target_ip,
-	unsigned int	send_sock,
-	unsigned int	receive_sock,
-	bool			ping_mode )
-{
-	char	receive_buffer[ sizeof(ip_header) + sizeof(icmp_header) + 1024];
-
-	unsigned short source_port = TRACE_ROUTE_BASE_PORT;
-	unsigned short target_port = TRACE_ROUTE_BASE_PORT;
-
-	int	seq			= 0;
-	int consec_bad	= 0;
-
-
-	bool	complete	= false;
-
-	bool	use_udp		= true;
-	bool	use_icmp	= true;
-
-	int	ttl;
-
-	if ( ping_mode ){
-
-		ttl = 32;
-
-	}else{
-
-		ttl = 0;
-	}
-
-	while( ttl < 33 && ( ping_mode || !complete )){
-
-	
-		complete = false;
-
-		if ( ping_mode ){
-
-			if ( consec_bad > 256 ){
-
-				throwException( env, "error", "too many consecutive bad packets in ping mode" );
-
-				return;
-			}
-
-		}else{
-
-			ttl++;
-		}
-
-			// try each node up to 3 times
-
-		bool probe_successful = false;
-
-		for (int probe_count=0; probe_count<3 && !( complete || probe_successful); probe_count++){
-
-			int	probe_sequence = seq++;
-
-			if ( !sendTraceRouteMessage( env, trace_id, ttl, send_sock, receive_sock, source_ip, source_port, target_ip, target_port + probe_sequence, use_udp, use_icmp )){
-			
-					// send failed, exception already reported
-
-				return;
-			}
-
-			unsigned long	start_ticks = 0;
-
-			while( !complete ){
-		
-				int receive_timeout = PROBE_TIMEOUT;
-
-				unsigned long	current_ticks = GetTickCount();
-
-				if ( start_ticks == 0 ){
-
-					start_ticks = current_ticks;
-
-				}else{
-
-					receive_timeout -= ( current_ticks - start_ticks );
-				}
-
-				if ( receive_timeout <= 0 ){
-
-					if ( !traceRouteReportTimeout( env, callback, ttl )){
-
-						return;
-					}
-
-					consec_bad = 0;
-
-					break;
-				}
-
-				if( setsockopt(receive_sock, SOL_SOCKET, SO_RCVTIMEO, (char *) &receive_timeout, sizeof(receive_timeout)) == SOCKET_ERROR ){
-
-					throwException( env, "setsockopt", "failed to set receive timeout socket options" );
-
-					return;
-				}
-
-				struct sockaddr_in from;
-				
-				int	from_len = sizeof( from );
-
-				unsigned int	read_len  = recvfrom( receive_sock, receive_buffer, sizeof( receive_buffer ), 0, (struct sockaddr *)&from, &from_len );
-				
-				if ( read_len == SOCKET_ERROR ){
-					
-					if ( WSAGetLastError() == WSAETIMEDOUT ){
-
-						if ( !traceRouteReportTimeout( env, callback, ttl )){
-
-							return;
-						}
-
-						consec_bad = 0;
-
-						break;
-
-					}else{
-
-						throwException( env, "recvfrom", "operation failed", WSAGetLastError());
-
-						return;
-					}
-
-				}else{
-
-					if ( read_len < sizeof( 4 )){
-
-						// printf( "invalid packet read - length < 4\n" );
-
-						consec_bad++;
-
-						continue;
-					}
-
-					ip_header	*ip = (ip_header *)receive_buffer;
-
-					unsigned char	ip_len		= ip->ip_header_len << 2;
-					unsigned short	total_len	= ntohs( ip->total_len );
-
-						// ensure we have a whole packet and an icmp reply
-
-					if ( read_len != total_len || read_len < ip_len + sizeof(icmp_header)){
-
-						// printf( "invalid packet read - read_len != total_len\n" );
-
-						consec_bad++;
-
-						continue;
-					}
-
-					int	elapsed_time = (int)( GetTickCount() - current_ticks );
-
-					icmp_header *icmp = (icmp_header *)(receive_buffer + ip_len );
-
-					unsigned char	icmp_type	= icmp->type;
-
-					if ( icmp_type == ICMP_TYPE_ECHO_REPLY ){
-
-						icmp_echo_header *icmp = (icmp_echo_header *)(receive_buffer + ip_len );
-
-						unsigned short	reply_seq = ntohs( icmp->sequence ) - TRACE_ROUTE_BASE_PORT;
-
-						if ( reply_seq != probe_sequence ){
-
-							consec_bad++;
-
-							continue;
-						}
-
-						if ( !traceRouteReportResult( env, callback, ttl, ntohl( from.sin_addr.s_addr ), elapsed_time, false )){
-
-							return;
-						}
-
-						consec_bad = 0;
-
-						if ( ping_mode ){
-
-							use_udp = false;
-						}
-
-						complete = true;
-
-						break;
-					}
-
-					if ( read_len != total_len || read_len < ip_len + sizeof(icmp_header) + sizeof( ip_header ) + 2){
-
-						// printf( "invalid packet read - read_len != total_len\n" );
-
-						consec_bad++;
-
-						continue;
-					}
-
-					
-					ip_header* old_ip = (ip_header *)(receive_buffer + ip_len + sizeof( icmp_header ));
-
-					if (	icmp_type != ICMP_TYPE_TTL_EXCEEDED &&
-							icmp_type != ICMP_TYPE_UNREACHABLE ){
-
-						// printf( "Unexpected ICMP reply type %d\n", icmp_type );
-
-						consec_bad++;
-
-						continue;
-					}
-		
-					if ( trace_id != ntohs(old_ip->ident )){
-
-							// not our reply
-
-						consec_bad++;
-
-						continue;
-					}
-
-					bool	reply_was_udp;
-
-					if ( old_ip->protocol == IPPROTO_ICMP ){
-
-						icmp_probe_packet*	probe = (icmp_probe_packet *)(receive_buffer + ip_len + sizeof( icmp_header ));
-
-						unsigned short	reply_seq = ntohs( probe->icmp.sequence ) - TRACE_ROUTE_BASE_PORT;
-
-						if ( reply_seq != probe_sequence ){
-
-							consec_bad++;
-
-							continue;
-						}
-
-						reply_was_udp = false;
-
-					}else{
-					
-						udp_probe_packet*	probe = (udp_probe_packet *)(receive_buffer + ip_len + sizeof( icmp_header ));
-
-						unsigned short	reply_seq = ntohs( probe->udp.dest_port ) - TRACE_ROUTE_BASE_PORT;
-
-						if ( reply_seq != probe_sequence ){
-
-							consec_bad++;
-
-							continue;
-						}
-
-						reply_was_udp = true;
-					}
-
-					probe_successful = true;
-
-					if ( icmp_type == ICMP_TYPE_ECHO_REPLY ){
-
-						complete = true;
-
-					}else if ( icmp_type == ICMP_TYPE_TTL_EXCEEDED ){
-					
-
-					}else if ( icmp_type == ICMP_TYPE_UNREACHABLE ){
-
-						unsigned char	icmp_code	= icmp->code;
-
-						if (	icmp_code == ICMP_CODE_PROTOCOL_UNREACHABLE ||
-								icmp_code == ICMP_CODE_PORT_UNREACHABLE ){
-
-								// these are received from the target host
-
-							complete	= true;
-
-						}else{
-
-						}		   
-					}
-
-					if ( ping_mode ){
-
-						if ( reply_was_udp ){
-
-							use_icmp = false;
-
-						}else{
-
-							use_udp = false;
-						}
-					}
-
-					if ( !traceRouteReportResult( env, callback, ttl, ntohl( from.sin_addr.s_addr ), elapsed_time, reply_was_udp )){
-
-						return;
-					}
-
-					consec_bad = 0;
-
-					break;
-				}
-	
-			}	
-		}
-	}
-
-	return;
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_traceRoute(
-	JNIEnv*		env,
-	jclass		cla, 
-	jint		trace_id,
-	jint		source_ip,
-	jint		target_ip,
-	jint		ping_mode,
-	jobject		callback )
-{
-	initialiseWinsock();
-
-	int receive_sock = socket( AF_INET, SOCK_RAW, IPPROTO_ICMP );
-
-	if ( receive_sock == SOCKET_ERROR ) {
-
-		throwException( env, "socket", "failed to create receive socket" );
-
-		return;
-	}
-
-	int receive_timeout = PROBE_TIMEOUT;
-
-	if( setsockopt(receive_sock, SOL_SOCKET, SO_RCVTIMEO, (char *) &receive_timeout, sizeof(receive_timeout)) == SOCKET_ERROR ){
-
-		closesocket(receive_sock);
-
-		throwException( env, "setsockopt", "failed to set receive timeout socket options" );
-
-		return;
-	}
-
-	int so_reuseaddress = 1;
-
-	if( setsockopt(receive_sock, SOL_SOCKET, SO_REUSEADDR, (char *) &so_reuseaddress, sizeof(so_reuseaddress)) == SOCKET_ERROR ){
-
-		closesocket(receive_sock);
-
-		throwException( env, "setsockopt", "failed to set receive reuse address socket options" );
-
-		return;
-	}
-
-		// we have to bind the socket before we can receive ICMP messages on it
-	
-	struct sockaddr_in				recv_bind_addr;
-
-	recv_bind_addr.sin_family		= AF_INET;
-	recv_bind_addr.sin_addr.s_addr	= htonl( source_ip );
-	recv_bind_addr.sin_port			= 0;
-
-	if ( bind( receive_sock, (struct sockaddr *)&recv_bind_addr, sizeof( recv_bind_addr )) == SOCKET_ERROR ){
-
-		closesocket(receive_sock);
-	
-		throwException( env, "socket", "failed to bind send socket" );
-
-		return;
-	}
-
-
-	int send_sock = socket( AF_INET, SOCK_RAW, IPPROTO_RAW );
-
-	if ( send_sock == SOCKET_ERROR ) {
-
-		closesocket(receive_sock);
-	
-		throwException( env, "socket", "failed to create send socket" );
-
-		return;
-	}
-
-	int	enable = 1;
-
-	if ( setsockopt(send_sock, IPPROTO_IP, IP_HDRINCL, (char *)&enable,sizeof(enable)) == SOCKET_ERROR ){
-
-		closesocket(send_sock);
-		closesocket(receive_sock);
-
-		throwException( env, "setsockopt", "failed to set receive socket options" );
-
-		return;
-	}
-
-
-	traceRoute( env, callback, (unsigned short)trace_id, (unsigned long)source_ip, (unsigned long)target_ip, send_sock, receive_sock, ping_mode==1?true:false );
-
-	closesocket(send_sock);
-	closesocket(receive_sock);
-}
-
-
-
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/aenet.h org/gudy/azureus2/platform/win32/access/impl/aenet.h
--- org/gudy/azureus2/platform.orig/win32/access/impl/aenet.h	2006-11-09 17:25:10.000000000 -0800
+++ org/gudy/azureus2/platform/win32/access/impl/aenet.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,102 +0,0 @@
-/*
- * Created on 1 Nov 2006
- * Created by Paul Gardner
- * Copyright (C) 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 63.529,40 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-#define PROBE_TIMEOUT			5000
-#define TRACE_ROUTE_BASE_PORT	48132
-
-#pragma pack (1)
-
-typedef struct
-{
-  unsigned char  ip_header_len:4;  
-  unsigned char  ip_version:4; 
-  unsigned char  tos;             
-  unsigned short total_len;       
-  unsigned short ident;          
-  unsigned short frag_and_flags;  
-  unsigned char  ttl;           
-  unsigned char  protocol;          
-  unsigned short checksum;    
-  unsigned int   source_ip;   
-  unsigned int   dest_ip;  
-} ip_header;
-
-
-typedef struct
-{
-	unsigned int	source_ip;
-	unsigned int	dest_ip;
-	unsigned char	zero;
-	unsigned char	protocol;
-	unsigned short	data_len;
-} pseudo_udp_header;
-
-typedef struct 
-{
-	unsigned short	source_port;
-	unsigned short	dest_port;		
-	unsigned short	data_len;	
-	unsigned short	checksum;	
-} udp_header;
-
-	// basic icmp header
-
-#define ICMP_TYPE_ECHO					8
-#define ICMP_TYPE_ECHO_REPLY			0
-#define ICMP_TYPE_UNREACHABLE			3
-#define ICMP_TYPE_TTL_EXCEEDED			11
-
-#define ICMP_CODE_PROTOCOL_UNREACHABLE	2
-#define ICMP_CODE_PORT_UNREACHABLE		3
-
-
-
-typedef struct
-{
-  unsigned char		type;   
-  unsigned char		code;  
-  unsigned short	checksum;  
-  unsigned int		unused;
-} icmp_header;
-
-typedef struct
-{
-  unsigned char		type;   
-  unsigned char		code;  
-  unsigned short	checksum;  
-  unsigned short	ident;
-  unsigned short	sequence;
-} icmp_echo_header;
-
-typedef struct 
-{
-    ip_header		ip;
-    udp_header		udp;
-	unsigned int	data;
-} udp_probe_packet;
-
-typedef struct 
-{
-    ip_header			ip;
-    icmp_echo_header	icmp;
-	unsigned int		data;
-} icmp_probe_packet;
\ No newline at end of file
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/aereg.cpp org/gudy/azureus2/platform/win32/access/impl/aereg.cpp
--- org/gudy/azureus2/platform.orig/win32/access/impl/aereg.cpp	2008-07-08 18:45:46.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/aereg.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,2115 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SARL au capital de 30,000 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-
-#include "stdafx.h"
-#include "aereg.h"
-#include "stdio.h"
-#include "stdlib.h"
-#include "windows.h"
-#include "shlwapi.h"
-#include "process.h"
-#include "shellapi.h"
-
-
-#include "org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h"
-
-
-#define VERSION "1.17"
-
- 
-HMODULE	application_module;
-bool	non_unicode			= false;
-
-jclass AEWin32AccessInterface_class;
-jclass AEWin32AccessExceptionImpl_class;
-
-UINT		uThreadId;
-HINSTANCE	hInstance;
-LRESULT CALLBACK WndProcW(HWND, UINT, WPARAM, LPARAM);
-void	RegisterWindowClassW();
-
-LRESULT CALLBACK WndProcA(HWND, UINT, WPARAM, LPARAM);
-void	RegisterWindowClassA();
-
-HRESULT
-callback(UINT	Msg, WPARAM	wParam, LPARAM	lParam) ;
-
-JavaVM*	jvm;
-
-BOOL APIENTRY 
-DllMain( 
-	HINSTANCE	hModule, 
-    DWORD		ul_reason_for_call, 
-    LPVOID		lpReserved )
-{
-    switch (ul_reason_for_call)
-	{
-		case DLL_PROCESS_ATTACH:
-		{
-			hInstance	= hModule;
-
-			OSVERSIONINFOA	osvi;
-
-			application_module = (HMODULE)hModule;
-
-			osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
-
-			GetVersionExA(&osvi);
-
-			non_unicode = ( osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS );
-
-			if ( non_unicode ){
-				RegisterWindowClassA();
-			}else{
-				RegisterWindowClassW();
-			}
-
-			break;
-		}
-		case DLL_THREAD_ATTACH:
-		case DLL_THREAD_DETACH:
-		case DLL_PROCESS_DETACH:
-			break;
-    }
-    return TRUE;
-}
-
-
-
-
-CAereg::CAereg()
-{ 
-	return; 
-}
-
-
-void
-throwException(
-	JNIEnv*			env,
-	char*			operation,
-	char*			message )
-{
-	bool	ok = false;
-
-	if ( AEWin32AccessExceptionImpl_class != NULL ){
-
-		jmethodID method = env->GetMethodID( AEWin32AccessExceptionImpl_class, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V" );
-	
-		if ( method != NULL ){
-
-	
-			jobject new_object =
-					env->NewObject( AEWin32AccessExceptionImpl_class, 
-									method, 
-									env->NewStringUTF((const char*)operation), 
-									env->NewStringUTF((const char*)message ));
-
-			if ( new_object != NULL ){
-
-				env->Throw( (jthrowable)new_object );
-
-				ok = true;
-			}
-		}else{
-
-			fprintf( stderr, "AEWin32AccessInterface: failed to resolve constructor" );
-		}
-	}
-
-	if ( !ok ){
-
-		fprintf( stderr, "AEWin32AccessInterface: failed to throw exception %s: %s\n", operation, message );
-	}
-}
-
-void
-throwException(
-	JNIEnv*			env,
-	char*			operation,
-	char*			message,
-	int				error_code )
-{
-	char	buffer[4096];
-
-	sprintf( buffer, "%s (error_code=%d)", message, error_code );
-
-	throwException( env, operation, buffer );
-}
-
-HKEY
-mapHKEY(
-	JNIEnv*		env,
-	jint		_type )
-{
-	if ( _type == org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CLASSES_ROOT ){
-
-		return( HKEY_CLASSES_ROOT );
-
-	}else if ( _type == org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CURRENT_CONFIG ){
-
-		return( HKEY_CURRENT_CONFIG );
-
-	}else if ( _type == org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_LOCAL_MACHINE ){
-
-		return( HKEY_LOCAL_MACHINE );
-
-	}else if ( _type == org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CURRENT_USER ){
-
-		return( HKEY_CURRENT_USER );
-
-	}else{
-
-		throwException( env, "readValue", "unsupported type" );
-
-		return( NULL );
-	}
-}
-
-
-// ******************************
-
-bool
-jstringToCharsW(
-	JNIEnv		*env,
-	jstring		jstr,
-	WCHAR		*chars,
-	int			chars_len )
-{
-	if ( jstr == NULL ){
-
-		chars[0] = 0;
-
-	}else{
-
-		int	jdata_len = env->GetStringLength(jstr);
-
-		if ( jdata_len >= chars_len ){
-
-			throwException( env, "jstringToChars", "jstring truncation occurred" );
-
-			return( false );
-		}
-
-		const jchar *jdata = env->GetStringChars( jstr, NULL );
-
-		for (int i=0;i<jdata_len;i++){
-
-			chars[i] = (WCHAR)jdata[i];
-		}
-
-		chars[jdata_len]=0;
-
-		env->ReleaseStringChars( jstr, jdata );
-	}
-
-	return( true );
-}
-
-
-// WINDOWS HOOK
-
-void
-RegisterWindowClassW() 
-{
-	WNDCLASSEXW wcex;
-
-	wcex.cbSize = sizeof(WNDCLASSEXW); 
-	wcex.style			= CS_HREDRAW | CS_VREDRAW;
-	wcex.lpfnWndProc	= WndProcW;
-	wcex.cbClsExtra		= 0;
-	wcex.cbWndExtra		= 0;
-	wcex.hInstance		= hInstance;
-	wcex.hIcon			= 0;
-	wcex.hCursor		= 0;
-	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW + 1);
-	wcex.lpszMenuName	= 0;
-	wcex.lpszClassName	= L"Azureus Window Hook";
-	wcex.hIconSm		= 0;
-
-	RegisterClassExW(&wcex);
-}
-
-
-LRESULT CALLBACK 
-WndProcW(
-	HWND hWnd, 
-	UINT Msg, 
-	WPARAM wParam, 
-	LPARAM lParam) 
-{
-	long res = callback( Msg, wParam, lParam );
-
-	if ( res != -1 ){
-
-		return( res );
-	}
-
-	return DefWindowProcW(hWnd, Msg, wParam, lParam);
-}
-
-unsigned WINAPI 
-CreateWndThreadW(
-	LPVOID pThreadParam) 
-{
-	HWND hWnd = CreateWindowW( L"Azureus Window Hook", NULL, WS_OVERLAPPEDWINDOW,
-									CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
-									NULL, NULL, hInstance, NULL);
-	if( hWnd == NULL){
-
-		printf( "Failed to create window\n" );
-
-		return( 0 );
-
-	}else{
-
-		MSG Msg;
-
-		while(GetMessageW(&Msg, hWnd, 0, 0)) {
-
-			TranslateMessage(&Msg);
-
-			DispatchMessageW(&Msg);
-		}
-
-		return Msg.wParam;
-	}
-} 
-
-
-//
-
-void
-RegisterWindowClassA() 
-{
-	WNDCLASSEXA wcex;
-
-	wcex.cbSize = sizeof(WNDCLASSEXA); 
-	wcex.style			= CS_HREDRAW | CS_VREDRAW;
-	wcex.lpfnWndProc	= WndProcA;
-	wcex.cbClsExtra		= 0;
-	wcex.cbWndExtra		= 0;
-	wcex.hInstance		= hInstance;
-	wcex.hIcon			= 0;
-	wcex.hCursor		= 0;
-	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW + 1);
-	wcex.lpszMenuName	= 0;
-	wcex.lpszClassName	= "Azureus Window Hook";
-	wcex.hIconSm		= 0;
-
-	RegisterClassExA(&wcex);
-}
-
-
-LRESULT CALLBACK 
-WndProcA(
-	HWND hWnd, 
-	UINT Msg, 
-	WPARAM wParam, 
-	LPARAM lParam) 
-{
-	long res = callback( Msg, wParam, lParam );
-
-	if ( res != -1 ){
-
-		return( res );
-	}
-
-	return DefWindowProcA(hWnd, Msg, wParam, lParam);
-}
-
-unsigned WINAPI 
-CreateWndThreadA(
-	LPVOID pThreadParam) 
-{
-	HWND hWnd = CreateWindowA( "Azureus Window Hook", NULL, WS_OVERLAPPEDWINDOW,
-									CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
-									NULL, NULL, hInstance, NULL);
-	if( hWnd == NULL){
-
-		printf( "Failed to create window\n" );
-
-		return( 0 );
-
-	}else{
-
-		MSG Msg;
-
-		while(GetMessageA(&Msg, hWnd, 0, 0)) {
-
-			TranslateMessage(&Msg);
-
-			DispatchMessageA(&Msg);
-		}
-
-		return Msg.wParam;
-	}
-} 
-
-
-HRESULT
-callback(
-	UINT	Msg, 
-	WPARAM	wParam, 
-	LPARAM	lParam) 
-{
-	JNIEnv *env; 
-
-	if ( jvm->AttachCurrentThread((void **)&env, NULL )){
-
-		fprintf( stderr, "failed to attach current thread to JVM\n" );
-
-		return( -1 );
-	}
-
-
-	jlong result = -1;
-
-	if ( AEWin32AccessInterface_class != NULL ){
-
-		jint	j_msg		= Msg;
-		jint	j_param1	= wParam;
-		jlong	j_param2	= lParam;
-
-
-		jmethodID method = env->GetStaticMethodID( AEWin32AccessInterface_class, "callback", "(IIJ)J");
-
-		if ( method != NULL ){
-
-			result = env->CallStaticLongMethod( AEWin32AccessInterface_class, method, j_msg, j_param1, j_param2 );
-
-		}else{
-					
-			fprintf( stderr, "failed to resolve callback method\n" );
-		}
-	}
-
-
-	jvm->DetachCurrentThread();
-
-	return((HRESULT)result ); 
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_initialise(
-	JNIEnv *env, 
-	jclass	cla )
-{
-	HANDLE hThread;
-
-	env->GetJavaVM(&jvm);
-
-	jclass local_ref = env->FindClass("org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessInterface" );
-
-	if ( local_ref == NULL ){
-
-		fprintf( stderr, "failed to find AEWin32AccessInterface class\n" );
-
-	}else{
-
-		AEWin32AccessInterface_class = (jclass)env->NewGlobalRef( local_ref );
-
-		env->DeleteLocalRef( local_ref );
-	}
-
-	local_ref = env->FindClass( "org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessExceptionImpl" );
-	
-	if ( local_ref == NULL ){
-
-		fprintf( stderr, "failed to find AEWin32AccessExceptionImpl class\n" );
-
-	}else{
-
-		AEWin32AccessExceptionImpl_class = (jclass)env->NewGlobalRef( local_ref );
-
-		env->DeleteLocalRef( local_ref );
-	}
-
-	if ( non_unicode ){
-
-		hThread = (HANDLE)_beginthreadex(NULL, 0, &CreateWndThreadA, NULL, 0, &uThreadId);
-
-	}else{
-
-		hThread = (HANDLE)_beginthreadex(NULL, 0, &CreateWndThreadW, NULL, 0, &uThreadId);
-	}
-
-	if(!hThread){
-
-		throwException( env, "_beginthreadex", "initialisation failed" );
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_destroy(
-	JNIEnv *env, 
-	jclass	cla )
-{
-	if ( uThreadId ){
-
-		PostThreadMessage(uThreadId, WM_QUIT, 0, 0);
-	}
-}
-
-// UNICODE METHODS
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getModuleNameW(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	WCHAR	buffer[2048];
-
-	if ( !GetModuleFileNameW(application_module, buffer, sizeof( buffer ))){
-
-
-		throwException( env, "getModuleName", "GetModuleFileName fails" );
-
-		return( NULL );
-	}
-
-	return( env->NewString(buffer, wcslen(buffer)));
-}
-
-
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getVersionW(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	jstring	result = env->NewStringUTF((char *)VERSION);
-
-	return( result );
-}
-
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readStringValueW(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	HKEY		key;
-	HKEY		subkey;
-	WCHAR		subkey_name[1024];
-	WCHAR		value_name[1024];
-
-	jstring		result	= NULL;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsW( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsW( env, _value_name, value_name, sizeof( value_name ))){
-
-		return( NULL );
-	}
-
-	if ( RegOpenKeyW( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-		BYTE	value[1024];
-		DWORD	value_length	= sizeof( value );
-		DWORD	type;
-
-		if ( RegQueryValueExW( subkey, value_name, NULL, &type, (unsigned char*)value, &value_length ) == ERROR_SUCCESS){
-
-			if ( type == REG_SZ || type == REG_EXPAND_SZ || type == REG_MULTI_SZ ){
-
-				if ( type == REG_EXPAND_SZ ){
-
-					WCHAR	expanded_value[2048];
-
-					ExpandEnvironmentStringsW((const WCHAR*)value, expanded_value, sizeof( expanded_value ));
-			
-					result = env->NewString(expanded_value,wcslen(expanded_value));
-
-				}else{
-
-
-					result = env->NewString((const WCHAR*)value,wcslen((WCHAR *)value));
-				}			
-
-			}else{
-
-				throwException( env, "readValue", "type mismach" );
-			}
-		}else{
-
-			throwException( env, "readStringValue", "RegQueryValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "readStringValue", "RegOpenKey failed" );
-	}
-
-	return( result );
-}
-
-JNIEXPORT jint JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readWordValueW(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	HKEY		key;
-	HKEY		subkey;
-	WCHAR		subkey_name[1024];
-	WCHAR		value_name[1024];
-
-	jint		result	= 0;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsW( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsW( env, _value_name, value_name, sizeof( value_name ))){
-
-		return( NULL );
-	}
-
-	if ( RegOpenKeyW( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-		BYTE	value[1024];
-		DWORD	value_length	= sizeof( value );
-		DWORD	type;
-
-		if ( RegQueryValueExW( subkey, value_name, NULL, &type, (unsigned char*)value, &value_length ) == ERROR_SUCCESS){
-
-			if ( type == REG_DWORD ){
-
-				result = (LONG)value[0];
-
-			}else{
-
-				throwException( env, "readValue", "type mismach" );
-			}
-		}else{
-
-			throwException( env, "readStringValue", "RegQueryValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "readStringValue", "RegOpenKey failed" );
-	}
-
-	return(result);
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeWordValueW(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name,
-	jint		_value_value )
-{
-	HKEY		key;
-	HKEY		subkey;
-	WCHAR		subkey_name[1024];
-	WCHAR		value_name[1024];
-	DWORD		value_value	= _value_value;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _value_name, value_name, sizeof( value_name ))){
-
-		return;
-	}
-
-
-
-	if ( RegCreateKeyExW( key, subkey_name, 0, REG_NONE, 0, KEY_ALL_ACCESS, NULL, &subkey, NULL ) == ERROR_SUCCESS ){
-
-
-		if ( RegSetValueExW( subkey, value_name, 0, REG_DWORD, (const BYTE*)&value_value, sizeof(DWORD)) == ERROR_SUCCESS){
-
-		}else{
-
-			throwException( env, "writeWordValue", "RegSetValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "writeWordValue", "RegCreateKeyEx failed" );
-	}
-
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeStringValueW(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name,
-	jstring		_value_value )
-{
-	HKEY		key;
-	HKEY		subkey;
-	WCHAR		subkey_name[1024];
-	WCHAR		value_name[1024];
-	WCHAR		value_value[1024];
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _value_name, value_name, sizeof( value_name ))){
-
-		return;
-	}
-
-
-	if ( !jstringToCharsW( env, _value_value, value_value, sizeof( value_value ))){
-
-		return;
-	}
-
-
-	if ( RegCreateKeyExW( key, subkey_name, 0, REG_NONE, 0, KEY_ALL_ACCESS, NULL, &subkey, NULL ) == ERROR_SUCCESS ){
-
-
-		if ( RegSetValueExW( subkey, value_name, 0, REG_SZ, (const BYTE*)value_value, (wcslen(value_value)+1)*sizeof(WCHAR)) == ERROR_SUCCESS){
-
-		}else{
-
-			throwException( env, "writeStringValue", "RegSetValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "writeStringValue", "RegCreateKeyEx failed" );
-	}
-
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteKeyW(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jboolean	_recursive )
-{
-	HKEY		key;
-	HKEY		subkey;
-	WCHAR		subkey_name[1024];
-
-	jstring		result	= NULL;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( RegOpenKeyW( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-
-		RegCloseKey(subkey);
-
-		if ( _recursive ){
-
-			if ( SHDeleteKeyW( key, subkey_name ) != ERROR_SUCCESS ){
-
-				throwException( env, "deleteKey", "SHDeleteKey failed" );
-			}
-		}else{
-
-			if ( RegDeleteKeyW( key, subkey_name ) != ERROR_SUCCESS ){
-
-				throwException( env, "deleteKey", "RegDeleteKey failed" );
-			}
-		}
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteValueW(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	HKEY		key;
-	HKEY		subkey;
-	WCHAR		subkey_name[1024];
-	WCHAR		value_name[1024];
-
-	jstring		result	= NULL;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _value_name, value_name, sizeof( value_name ))){
-
-		return;
-	}
-
-	if ( RegOpenKeyW( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-
-		RegCloseKey(subkey);
-
-		if ( SHDeleteValueW( key, subkey_name, value_name ) != ERROR_SUCCESS ){
-
-			throwException( env, "deleteValue", "SHDeleteValue failed" );
-		}
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_createProcessW(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_command_line, 
-	jboolean	_inherit_handles )
-{
-	WCHAR		command_line[16000];
-
-	STARTUPINFOW			start_info;
-	PROCESS_INFORMATION		proc_info;
-
-	if ( !jstringToCharsW( env, _command_line, command_line, sizeof( command_line ))){
-
-		return;
-	}
-
-	memset( &start_info, 0, sizeof( STARTUPINFO ));
-
-	start_info.cb = sizeof( STARTUPINFO );
-
-	if ( CreateProcessW(
-			NULL,				// LPCTSTR lpApplicationName,
-			command_line,		// LPTSTR lpCommandLine,
-			NULL,				// LPSECURITY_ATTRIBUTES lpProcessAttributes,
-			NULL,				// LPSECURITY_ATTRIBUTES lpThreadAttributes,
-			_inherit_handles,	// BOOL bInheritHandles,
-			DETACHED_PROCESS,	// DWORD dwCreationFlags,
-			NULL,				// LPVOID lpEnvironment,
-			NULL,				// LPCTSTR lpCurrentDirectory,
-			&start_info,		// LPSTARTUPINFO lpStartupInfo,
-			&proc_info )){		// LPPROCESS_INFORMATION lpProcessInformation
-
-
-		CloseHandle( proc_info.hThread );
-        CloseHandle( proc_info.hProcess );
-
-	}else{
-
-		throwException( env, "createProcess", "CreateProcess failed" );
-	}
-};
-
-
-JNIEXPORT jint JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecAndWaitW(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_file,
-	jstring		_params )
-{
-	WCHAR		file[2048];
-	WCHAR		params[2048];
-
-	if ( !jstringToCharsW( env, _file, file, sizeof( file ))){
-
-		return(0);
-	}
-
-	if ( !jstringToCharsW( env, _params, params, sizeof( params ))){
-
-		return(0);
-	}
-
-    SHELLEXECUTEINFO shExecInfo;
-
-    shExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);
-
-    shExecInfo.fMask		= SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT;
-    shExecInfo.hwnd			= NULL;
-    shExecInfo.lpVerb		= L"runas";
-    shExecInfo.lpFile		= file;
-    shExecInfo.lpParameters = params;
-    shExecInfo.lpDirectory	= NULL;
-    shExecInfo.nShow		= SW_SHOWNORMAL;
-    shExecInfo.hInstApp		= NULL;
-
-    ShellExecuteExW(&shExecInfo);
-
-
-	int res = (int)shExecInfo.hInstApp;
-
-	if ( res <= 32 ){
-
-		throwException( env, "shellExec", "ShellExecW failed", res );
-
-		return( 0 );
-
-	}else{
-
-		HANDLE process = shExecInfo.hProcess;
-
-		WaitForSingleObject( process, INFINITE );
-
-		DWORD result;
-
-		if ( GetExitCodeProcess( process, &result ) == 0 ){
-
-			throwException( env, "shellExec", "GetExitCodeProcess failed", GetLastError());
-		}
-
-		CloseHandle( process );
-		
-		return((jint)result);
-	}
-};
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_moveToRecycleBinW(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _fileName )
-
-{
-	WCHAR		file_name[16000];
-
-    SHFILEOPSTRUCTW opFile;
-    
-	if ( !jstringToCharsW( env, _fileName, file_name, sizeof( file_name )-1)){
-
-		return;
-	}
-
-    HANDLE file = CreateFileW (	file_name, 
-								GENERIC_READ, 
-								FILE_SHARE_READ, 
-								NULL, 
-								OPEN_EXISTING, 
-								FILE_ATTRIBUTE_NORMAL, 
-								NULL );
-    
-		// Checks if file exists
-
-    if ( file == INVALID_HANDLE_VALUE ){
-   
-		throwException( env, "moveToRecycleBin", "file not found" );
-
-        return;
-    }
-    
-    CloseHandle(file);
-
-    file_name[ wcslen(file_name)+1 ] = 0;
-
-    ZeroMemory(&opFile, sizeof(opFile));
-
-    opFile.wFunc = FO_DELETE;
-
-    opFile.pFrom = file_name;
-
-    opFile.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION | FOF_SILENT;
-    
-    if (SHFileOperationW (&opFile)){
-
-        throwException( env, "moveToRecycleBin", "SHFileOperation failed" );
-    }
-}
-
-#define myheapalloc(x) (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x))
-#define myheapfree(x)  (HeapFree(GetProcessHeap(), 0, x))
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_copyPermissionW(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _fileNameIn,
-	jstring _fileNameOut )
-{
-	WCHAR		file_name_in[2048];
-	WCHAR		file_name_out[2048];
-    
-	if ( !jstringToCharsW( env, _fileNameIn, file_name_in, sizeof( file_name_in )-1)){
-
-		return;
-	}
-
-	if ( !jstringToCharsW( env, _fileNameOut, file_name_out, sizeof( file_name_out )-1)){
-
-		return;
-	}
-
-	SECURITY_INFORMATION secInfo	= DACL_SECURITY_INFORMATION;
-	DWORD				 cbFileSD   = 0;
-	PSECURITY_DESCRIPTOR pFileSD	= NULL;
-
-    BOOL ok = GetFileSecurityW(file_name_in, secInfo, pFileSD, 0, &cbFileSD);
-
-      // API should have failed with insufficient buffer.
-
-	if ( ok ){
-     
-		throwException( env, "copyPermission", "GetFileSecurity ok" );
-
-        return;
-
-    }else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
-
-		throwException( env, "copyPermission", "from file not found" );
-
-		return;
-
-	}else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
-
-		throwException( env, "copyPermission", "GetFileSecurity unexpected response", GetLastError() );
-
-        return;
-	
-	}else{
-
-		pFileSD	= myheapalloc( cbFileSD );
-      
-		if (!pFileSD) {
-  
-			throwException( env, "copyPermission", "no memory" );
-
-			return;
-		}
-
-		ok = GetFileSecurityW(file_name_in, secInfo, pFileSD, cbFileSD, &cbFileSD );
-      
-		if (!ok) {
-
-			myheapfree( pFileSD );
-
-			throwException( env, "copyPermission", "GetFileSecurity", GetLastError());
-
-			return;
-		}	
-
-		ok = SetFileSecurityW( file_name_out, secInfo, pFileSD );
-
-	 	myheapfree( pFileSD );
-
-		if ( !ok ){
-
-			if (GetLastError() == ERROR_FILE_NOT_FOUND) {
-
-				throwException( env, "copyPermission", "to file not found" );
-
-			}else{
-
-				throwException( env, "copyPermission", "SetFileSecurity unexpected response", GetLastError() );
-
-			}
-		}
-	}
-}
-
-JNIEXPORT jboolean JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_testNativeAvailabilityW(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _name )
-{
-	WCHAR		name[2048];
-    
-	if ( !jstringToCharsW( env, _name, name, sizeof( name )-1)){
-
-		return( 0 );
-	}
-
-
-	HMODULE	mod = 
-		LoadLibraryExW( 
-			name,
-			NULL,
-			LOAD_LIBRARY_AS_DATAFILE );
-
-	if ( mod == NULL ){
-
-		return( 0 );
-
-	}else{
-
-		FreeLibrary( mod );
-
-		return( 1 );
-	}
-}
-
-// 1.3
-JNIEXPORT jint JNICALL
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecuteW(
-	JNIEnv	*env,
-	jclass	cla,
-	jstring _operation,
-	jstring	_file,
-	jstring _parameters,
-	jstring _directory,
-	jint _showCmd )
-{
-	WCHAR		operation[20];
-	WCHAR		file[5192];
-	WCHAR		parameters[16000];
-	WCHAR		directory[5192];
-	INT			showCmd = _showCmd;
-	
-	if ( !jstringToCharsW( env, _operation, operation, sizeof( operation ))){
-		return -1;
-	}
-
-	if ( !jstringToCharsW( env, _file, file, sizeof( file ))){
-		return -1;
-	}
-
-	if ( !jstringToCharsW( env, _parameters, parameters, sizeof( parameters ))){
-		return -1;
-	}
-
-	if ( !jstringToCharsW( env, _directory, directory, sizeof( directory ))){
-		return -1;
-	}
-	
-	// Not sure if ShellExecute treats "\0" as NULL, so do explicit check 
-	return(jint) ShellExecuteW(NULL,
-			_operation == NULL ? NULL : operation,
-			_file == NULL ? NULL : file,
-			_parameters == NULL ? NULL : parameters,
-			_directory == NULL ? NULL : directory,
-			showCmd);
-}
-
-
-// NON-UNICODE VARIANT FOR WIN95,98,ME
-
-
-
-
-bool
-jstringToCharsA(
-	JNIEnv		*env,
-	jstring		jstr,
-	char		*chars,
-	int			chars_len )
-{
-	if ( jstr == NULL ){
-
-		chars[0] = 0;
-
-	}else{
-
-		int	jdata_len = env->GetStringLength(jstr);
-
-		if ( jdata_len >= chars_len ){
-
-			throwException( env, "jstringToChars", "jstring truncation occurred" );
-
-			return( false );
-		}
-
-		const jchar *jdata = env->GetStringChars( jstr, NULL );
-
-		for (int i=0;i<jdata_len;i++){
-
-			chars[i] = (char)jdata[i];
-		}
-
-		chars[jdata_len]=0;
-
-		env->ReleaseStringChars( jstr, jdata );
-	}
-
-	return( true );
-}
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getModuleNameA(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	char	buffer[2048];
-
-	if ( !GetModuleFileNameA(application_module, buffer, sizeof( buffer ))){
-
-
-		throwException( env, "getModuleName", "GetModuleFileName fails" );
-
-		return( NULL );
-	}
-
-	return( env->NewStringUTF((char *)buffer));
-}
-
-
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getVersionA(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	jstring	result = env->NewStringUTF((char *)VERSION);
-
-	return( result );
-}
-
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readStringValueA(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	HKEY		key;
-	HKEY		subkey;
-	char		subkey_name[1024];
-	char		value_name[1024];
-
-	jstring		result	= NULL;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsA( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsA( env, _value_name, value_name, sizeof( value_name ))){
-
-		return( NULL );
-	}
-
-	if ( RegOpenKeyA( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-		BYTE	value[1024];
-		DWORD	value_length	= sizeof( value );
-		DWORD	type;
-
-		if ( RegQueryValueExA( subkey, value_name, NULL, &type, (unsigned char*)value, &value_length ) == ERROR_SUCCESS){
-
-			if ( type == REG_SZ || type == REG_EXPAND_SZ || type == REG_MULTI_SZ ){
-
-				if ( type == REG_EXPAND_SZ ){
-
-					char	expanded_value[2048];
-
-					ExpandEnvironmentStringsA((const char*)value, expanded_value, sizeof( expanded_value ));
-			
-					result = env->NewStringUTF((char *)expanded_value);
-
-				}else{
-
-
-					result = env->NewStringUTF((char *)value);
-				}			
-
-			}else{
-
-				throwException( env, "readValue", "type mismach" );
-			}
-		}else{
-
-			throwException( env, "readStringValue", "RegQueryValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "readStringValue", "RegOpenKey failed" );
-	}
-
-	return( result );
-}
-
-JNIEXPORT jint JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readWordValueA(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	HKEY		key;
-	HKEY		subkey;
-	char		subkey_name[1024];
-	char		value_name[1024];
-
-	jint		result	= 0;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsA( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return( NULL );
-	}
-
-	if ( !jstringToCharsA( env, _value_name, value_name, sizeof( value_name ))){
-
-		return( NULL );
-	}
-
-	if ( RegOpenKeyA( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-		BYTE	value[1024];
-		DWORD	value_length	= sizeof( value );
-		DWORD	type;
-
-		if ( RegQueryValueExA( subkey, value_name, NULL, &type, (unsigned char*)value, &value_length ) == ERROR_SUCCESS){
-
-			if ( type == REG_DWORD ){
-
-				result = (LONG)value[0];
-
-			}else{
-
-				throwException( env, "readValue", "type mismach" );
-			}
-		}else{
-
-			throwException( env, "readStringValue", "RegQueryValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "readStringValue", "RegOpenKey failed" );
-	}
-
-	return(result);
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeWordValueA(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name,
-	jint		_value_value )
-{
-	HKEY		key;
-	HKEY		subkey;
-	char		subkey_name[1024];
-	char		value_name[1024];
-	DWORD		value_value	= _value_value;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _value_name, value_name, sizeof( value_name ))){
-
-		return;
-	}
-
-
-
-	if ( RegCreateKeyExA( key, subkey_name, 0, REG_NONE, 0, KEY_ALL_ACCESS, NULL, &subkey, NULL ) == ERROR_SUCCESS ){
-
-
-		if ( RegSetValueExA( subkey, value_name, 0, REG_DWORD, (const BYTE*)&value_value, sizeof(DWORD)) == ERROR_SUCCESS){
-
-		}else{
-
-			throwException( env, "writeWordValue", "RegSetValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "writeWordValue", "RegCreateKeyEx failed" );
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeStringValueA(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name,
-	jstring		_value_value )
-{
-	HKEY		key;
-	HKEY		subkey;
-	char		subkey_name[1024];
-	char		value_name[1024];
-	char		value_value[1024];
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _value_name, value_name, sizeof( value_name ))){
-
-		return;
-	}
-
-
-	if ( !jstringToCharsA( env, _value_value, value_value, sizeof( value_value ))){
-
-		return;
-	}
-
-
-	if ( RegCreateKeyExA( key, subkey_name, 0, REG_NONE, 0, KEY_ALL_ACCESS, NULL, &subkey, NULL ) == ERROR_SUCCESS ){
-
-
-		if ( RegSetValueExA( subkey, value_name, 0, REG_SZ, (const BYTE*)value_value, strlen(value_value)+1 ) == ERROR_SUCCESS){
-
-		}else{
-
-			throwException( env, "writeStringValue", "RegSetValueEx failed" );
-		}
-
-		RegCloseKey(subkey);
-
-	}else{
-
-		throwException( env, "writeStringValue", "RegCreateKeyEx failed" );
-	}
-
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteKeyA(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jboolean	_recursive )
-{
-	HKEY		key;
-	HKEY		subkey;
-	char		subkey_name[1024];
-
-	jstring		result	= NULL;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( RegOpenKeyA( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-
-		RegCloseKey(subkey);
-
-		if ( _recursive ){
-
-			if ( SHDeleteKeyA( key, subkey_name ) != ERROR_SUCCESS ){
-
-				throwException( env, "deleteKey", "SHDeleteKey failed" );
-			}
-		}else{
-
-			if ( RegDeleteKeyA( key, subkey_name ) != ERROR_SUCCESS ){
-
-				throwException( env, "deleteKey", "RegDeleteKey failed" );
-			}
-		}
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteValueA(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	HKEY		key;
-	HKEY		subkey;
-	char		subkey_name[1024];
-	char		value_name[1024];
-
-	jstring		result	= NULL;
-
-	key	= mapHKEY( env, _type );
-
-	if ( key == NULL ){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _subkey_name, subkey_name, sizeof( subkey_name ))){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _value_name, value_name, sizeof( value_name ))){
-
-		return;
-	}
-
-	if ( RegOpenKeyA( key, subkey_name, &subkey ) == ERROR_SUCCESS ){
-
-
-		RegCloseKey(subkey);
-
-		if ( SHDeleteValueA( key, subkey_name, value_name ) != ERROR_SUCCESS ){
-
-			throwException( env, "deleteValue", "SHDeleteValue failed" );
-		}
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_createProcessA(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_command_line, 
-	jboolean	_inherit_handles )
-{
-	char		command_line[16000];
-
-	STARTUPINFOA			start_info;
-	PROCESS_INFORMATION		proc_info;
-
-	if ( !jstringToCharsA( env, _command_line, command_line, sizeof( command_line ))){
-
-		return;
-	}
-
-	memset( &start_info, 0, sizeof( STARTUPINFOA ));
-
-	start_info.cb = sizeof( STARTUPINFOA );
-
-	if ( CreateProcessA(
-			NULL,				// LPCTSTR lpApplicationName,
-			command_line,		// LPTSTR lpCommandLine,
-			NULL,				// LPSECURITY_ATTRIBUTES lpProcessAttributes,
-			NULL,				// LPSECURITY_ATTRIBUTES lpThreadAttributes,
-			_inherit_handles,	// BOOL bInheritHandles,
-			DETACHED_PROCESS,	// DWORD dwCreationFlags,
-			NULL,				// LPVOID lpEnvironment,
-			NULL,				// LPCTSTR lpCurrentDirectory,
-			&start_info,		// LPSTARTUPINFO lpStartupInfo,
-			&proc_info )){		// LPPROCESS_INFORMATION lpProcessInformation
-
-
-		CloseHandle( proc_info.hThread );
-        CloseHandle( proc_info.hProcess );
-
-	}else{
-
-		throwException( env, "createProcess", "CreateProcess failed" );
-	}
-};
-
-JNIEXPORT jint JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecAndWaitA(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_file,
-	jstring		_params )
-{
-	char		file[2048];
-	char		params[2048];
-
-	if ( !jstringToCharsA( env, _file, file, sizeof( file ))){
-
-		return(0);
-	}
-
-	if ( !jstringToCharsA( env, _params, params, sizeof( params ))){
-
-		return(0);
-	}
-
-    SHELLEXECUTEINFOA shExecInfo;
-
-    shExecInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
-
-    shExecInfo.fMask		= SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT;
-    shExecInfo.hwnd			= NULL;
-    shExecInfo.lpVerb		= "runas";
-    shExecInfo.lpFile		= file;
-    shExecInfo.lpParameters = params;
-    shExecInfo.lpDirectory	= NULL;
-    shExecInfo.nShow		= SW_SHOWNORMAL;
-    shExecInfo.hInstApp		= NULL;
-
-    ShellExecuteExA(&shExecInfo);
-
-
-	int res = (int)shExecInfo.hInstApp;
-
-	if ( res <= 32 ){
-
-		throwException( env, "shellExec", "ShellExecA failed", res );
-
-		return( 0 );
-
-	}else{
-
-		HANDLE process = shExecInfo.hProcess;
-
-		WaitForSingleObject( process, INFINITE );
-
-		DWORD result;
-
-		if ( GetExitCodeProcess( process, &result ) == 0 ){
-
-			throwException( env, "shellExec", "GetExitCodeProcess failed", GetLastError());
-		}
-
-		CloseHandle( process );
-		
-		return((jint)result);
-	}
-};
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_moveToRecycleBinA(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _fileName )
-
-{
-	char		file_name[16000];
-
-    SHFILEOPSTRUCTA opFile;
-    
-	if ( !jstringToCharsA( env, _fileName, file_name, sizeof( file_name )-1)){
-
-		return;
-	}
-
-    HANDLE file = CreateFileA (	file_name, 
-								GENERIC_READ, 
-								FILE_SHARE_READ, 
-								NULL, 
-								OPEN_EXISTING, 
-								FILE_ATTRIBUTE_NORMAL, 
-								NULL );
-    
-		// Checks if file exists
-
-    if ( file == INVALID_HANDLE_VALUE ){
-   
-		throwException( env, "moveToRecycleBin", "file not found" );
-
-        return;
-    }
-    
-    CloseHandle(file);
-
-    file_name[ strlen(file_name)+1 ] = 0;
-
-    ZeroMemory(&opFile, sizeof(opFile));
-
-    opFile.wFunc = FO_DELETE;
-
-    opFile.pFrom = file_name;
-
-    opFile.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION | FOF_SILENT;
-    
-    if (SHFileOperationA (&opFile)){
-
-        throwException( env, "moveToRecycleBin", "SHFileOperation failed" );
-    }
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_copyPermissionA(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _fileNameIn,
-	jstring _fileNameOut )
-{
-	char		file_name_in[2048];
-	char		file_name_out[2048];
-    
-	if ( !jstringToCharsA( env, _fileNameIn, file_name_in, sizeof( file_name_in )-1)){
-
-		return;
-	}
-
-	if ( !jstringToCharsA( env, _fileNameOut, file_name_out, sizeof( file_name_out )-1)){
-
-		return;
-	}
-
-	SECURITY_INFORMATION secInfo	= DACL_SECURITY_INFORMATION;
-	DWORD				 cbFileSD   = 0;
-	PSECURITY_DESCRIPTOR pFileSD	= NULL;
-
-    BOOL ok = GetFileSecurityA(file_name_in, secInfo, pFileSD, 0, &cbFileSD);
-
-      // API should have failed with insufficient buffer.
-
-	if ( ok ){
-     
-		throwException( env, "copyPermission", "GetFileSecurity ok" );
-
-        return;
-
-    }else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
-
-		throwException( env, "copyPermission", "from file not found" );
-
-		return;
-
-	}else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
-
-		throwException( env, "copyPermission", "GetFileSecurity unexpected response", GetLastError() );
-
-        return;
-	
-	}else{
-
-		pFileSD	= myheapalloc( cbFileSD );
-      
-		if (!pFileSD) {
-  
-			throwException( env, "copyPermission", "no memory" );
-
-			return;
-		}
-
-		ok = GetFileSecurityA(file_name_in, secInfo, pFileSD, cbFileSD, &cbFileSD );
-      
-		if (!ok) {
-
-			myheapfree( pFileSD );
-
-			throwException( env, "copyPermission", "GetFileSecurity", GetLastError());
-
-			return;
-		}	
-
-		ok = SetFileSecurityA( file_name_out, secInfo, pFileSD );
-
-	 	myheapfree( pFileSD );
-
-		if ( !ok ){
-
-			if (GetLastError() == ERROR_FILE_NOT_FOUND) {
-
-				throwException( env, "copyPermission", "to file not found" );
-
-			}else{
-
-				throwException( env, "copyPermission", "SetFileSecurity unexpected response", GetLastError() );
-
-			}
-		}
-	}
-}
-
-JNIEXPORT jboolean JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_testNativeAvailabilityA(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _name )
-{
-	char		name[2048];
-    
-	if ( !jstringToCharsA( env, _name, name, sizeof( name )-1)){
-
-		return( 0 );
-	}
-
-
-	HMODULE	mod = 
-		LoadLibraryExA( 
-			name,
-			NULL,
-			LOAD_LIBRARY_AS_DATAFILE );
-
-	if ( mod == NULL ){
-
-		return( 0 );
-
-	}else{
-
-		FreeLibrary( mod );
-
-		return( 1 );
-	}
-}
-
-// 1.3
-JNIEXPORT jint JNICALL
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecuteA(
-	JNIEnv	*env,
-	jclass	cla,
-	jstring _operation,
-	jstring	_file,
-	jstring _parameters,
-	jstring _directory,
-	jint _showCmd )
-{
-	char	operation[20];
-	char	file[5192];
-	char	parameters[16000];
-	char	directory[5192];
-	INT		showCmd = _showCmd;
-	
-	if ( !jstringToCharsA( env, _operation, operation, sizeof( operation ))){
-		return -1;
-	}
-
-	if ( !jstringToCharsA( env, _file, file, sizeof( file ))){
-		return -1;
-	}
-
-	if ( !jstringToCharsA( env, _parameters, parameters, sizeof( parameters ))){
-		return -1;
-	}
-
-	if ( !jstringToCharsA( env, _directory, directory, sizeof( directory ))){
-		return -1;
-	}
-	
-	// Not sure if ShellExecute treats "\0" as NULL, so do explicit check 
-	return (jint)ShellExecuteA(NULL,
-			_operation == NULL ? NULL : operation,
-			_file == NULL ? NULL : file,
-			_parameters == NULL ? NULL : parameters,
-			_directory == NULL ? NULL : directory,
-			showCmd);
-}
-
-
-// BLAH
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getModuleName(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	if ( non_unicode ){
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getModuleNameA( env, cla ));
-	}else{
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getModuleNameW( env, cla ));
-	}
-}
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getVersion(
-	JNIEnv		*env,
-	jclass		cla )
-{
-	if ( non_unicode ){
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getVersionA( env, cla ));
-	}else{
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getVersionW( env, cla ));
-	}
-}
-
-JNIEXPORT jstring JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readStringValue(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	if ( non_unicode ){
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readStringValueA( env, cla, _type, _subkey_name, _value_name ));
-	}else{
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readStringValueW( env, cla, _type, _subkey_name, _value_name ));
-	}
-}
-
-JNIEXPORT jint JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readWordValue(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	if ( non_unicode ){
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readWordValueA( env, cla, _type, _subkey_name, _value_name ));
-	}else{
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readWordValueW( env, cla, _type, _subkey_name, _value_name ));
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeStringValue(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name,
-	jstring		_value_value )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeStringValueA( env, cla, _type, _subkey_name, _value_name, _value_value );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeStringValueW( env, cla, _type, _subkey_name, _value_name, _value_value );
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeWordValue(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name,
-	jint		_value_value )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeWordValueA( env, cla, _type, _subkey_name, _value_name, _value_value );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeWordValueW( env, cla, _type, _subkey_name, _value_name, _value_value );
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteKey(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jboolean	_recursive )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteKeyA( env, cla, _type, _subkey_name, _recursive );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteKeyW( env, cla, _type, _subkey_name, _recursive );
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteValue(
-	JNIEnv		*env,
-	jclass		cla,
-	jint		_type, 
-	jstring		_subkey_name,
-	jstring		_value_name )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteValueA( env, cla, _type, _subkey_name, _value_name );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteValueW( env, cla, _type, _subkey_name, _value_name );
-	}
-}
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_createProcess(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_command_line, 
-	jboolean	_inherit_handles )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_createProcessA( env, cla, _command_line, _inherit_handles );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_createProcessW( env, cla, _command_line, _inherit_handles );
-	}
-}
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_moveToRecycleBin(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_file_name )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_moveToRecycleBinA( env, cla, _file_name );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_moveToRecycleBinW( env, cla, _file_name );
-	}
-}
-
-
-
-JNIEXPORT void JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_copyPermission(
-	JNIEnv *env, 
-	jclass	cla, 
-	jstring _fileNameIn,
-	jstring _fileNameOut )
-{
-	if ( non_unicode ){
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_copyPermissionA( env, cla, _fileNameIn, _fileNameOut );
-	}else{
-		Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_copyPermissionW( env, cla, _fileNameIn, _fileNameOut );
-	}
-}
-
-JNIEXPORT jboolean JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_testNativeAvailability(
-	JNIEnv	*env,
-	jclass	cla,
-	jstring	name )
-{
-	if ( non_unicode ){
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_testNativeAvailabilityA( env, cla,name ));
-	}else{
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_testNativeAvailabilityW( env, cla, name ));
-	}
-}
-
-JNIEXPORT jint JNICALL
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecute(
-	JNIEnv	*env,
-	jclass	cla,
-	jstring operation,
-	jstring	file,
-	jstring parameters,
-	jstring directory,
-	jint showCmd )
-{
-	if ( non_unicode ){
-		return
-			Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecuteA(
-				env, cla, operation, file, parameters, directory, showCmd );
-	}else{
-		return
-			Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecuteW(
-				env, cla, operation, file, parameters, directory, showCmd );
-	}
-}
-
-JNIEXPORT jint JNICALL 
-Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecuteAndWait(
-	JNIEnv*		env,
-	jclass		cla, 
-	jstring		_command_line, 
-	jstring		_params )
-{
-	if ( non_unicode ){
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecAndWaitA( env, cla, _command_line, _params ));
-	}else{
-		return( Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecAndWaitW( env, cla, _command_line, _params ));
-	}
-}
-
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/aereg.dsp org/gudy/azureus2/platform/win32/access/impl/aereg.dsp
--- org/gudy/azureus2/platform.orig/win32/access/impl/aereg.dsp	2006-11-17 13:27:12.000000000 -0800
+++ org/gudy/azureus2/platform/win32/access/impl/aereg.dsp	1969-12-31 16:00:00.000000000 -0800
@@ -1,136 +0,0 @@
-# Microsoft Developer Studio Project File - Name="aereg" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
-
-CFG=aereg - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "aereg.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "aereg.mak" CFG="aereg - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "aereg - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "aereg - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "aereg - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "AEREG_EXPORTS" /Yu"stdafx.h" /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I "C:\JDK1.4\include" /I "C:\JDK1.4\include\win32" /I "C:\j2sdk1.4.2_04\include" /I "C:\j2sdk1.4.2_04\include\win32" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "UNICODE" /D "_USRDLL" /D "AEREG_EXPORTS" /FR /Yu"stdafx.h" /FD /c
-# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x809 /d "NDEBUG"
-# ADD RSC /l 0x809 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib shlwapi.lib Ws2_32.lib /nologo /dll /machine:I386
-
-!ELSEIF  "$(CFG)" == "aereg - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "AEREG_EXPORTS" /Yu"stdafx.h" /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "C:\j2sdk1.4.2_04\include" /I "C:\j2sdk1.4.2_04\include\win32" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "AEREG_EXPORTS" /FR /Yu"stdafx.h" /FD /GZ /c
-# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x809 /d "_DEBUG"
-# ADD RSC /l 0x809 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib shlwapi.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "aereg - Win32 Release"
-# Name "aereg - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\aenet.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\aereg.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\StdAfx.cpp
-# ADD CPP /Yc"stdafx.h"
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\aenet.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\aereg.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\StdAfx.h
-# End Source File
-# End Group
-# Begin Group "Resource Files"
-
-# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-# End Group
-# Begin Source File
-
-SOURCE=.\ReadMe.txt
-# End Source File
-# End Target
-# End Project
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/aereg.dsw org/gudy/azureus2/platform/win32/access/impl/aereg.dsw
--- org/gudy/azureus2/platform.orig/win32/access/impl/aereg.dsw	2004-04-17 10:22:32.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/aereg.dsw	1969-12-31 16:00:00.000000000 -0800
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: "aereg"=.\aereg.dsp - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=<5>
-{{{
-}}}
-
-Package=<3>
-{{{
-}}}
-
-###############################################################################
-
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/aereg.h org/gudy/azureus2/platform/win32/access/impl/aereg.h
--- org/gudy/azureus2/platform.orig/win32/access/impl/aereg.h	2006-11-09 17:25:10.000000000 -0800
+++ org/gudy/azureus2/platform/win32/access/impl/aereg.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,41 +0,0 @@
-
-// The following ifdef block is the standard way of creating macros which make exporting 
-// from a DLL simpler. All files within this DLL are compiled with the AEREG_EXPORTS
-// symbol defined on the command line. this symbol should not be defined on any project
-// that uses this DLL. This way any other project whose source files include this file see 
-// AEREG_API functions as being imported from a DLL, wheras this DLL sees symbols
-// defined with this macro as being exported.
-#ifdef AEREG_EXPORTS
-#define AEREG_API __declspec(dllexport)
-#else
-#define AEREG_API __declspec(dllimport)
-#endif
-
-// This class is exported from the aereg.dll
-class AEREG_API CAereg {
-public:
-	CAereg(void);
-	// TODO: add your methods here.
-};
-
-#include <jni.h>
-
-extern void
-throwException(
-	JNIEnv*			env,
-	char*			operation,
-	char*			message );
-
-extern void
-throwException(
-	JNIEnv*			env,
-	char*			operation,
-	char*			message,
-	int				error_code );
-
-extern bool
-jstringToCharsA(
-	JNIEnv		*env,
-	jstring		jstr,
-	char		*chars,
-	int			chars_len );
\ No newline at end of file
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessCallback.java org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessCallback.java
--- org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessCallback.java	2006-11-09 17:25:10.000000000 -0800
+++ org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessCallback.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,37 +0,0 @@
-/*
- * Created on 26-Jan-2006
- * Created by Paul Gardner
- * Copyright (C) 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access.impl;
-
-public interface 
-AEWin32AccessCallback 
-{
-	public long
-	windowsMessage(
-		int		msg,
-		int		param1,
-		long	param2 );
-	
-	public long
-	generalMessage(
-		String	msg );
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessExceptionImpl.java org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessExceptionImpl.java
--- org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessExceptionImpl.java	2008-05-14 15:08:04.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessExceptionImpl.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,44 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access.impl;
-
-/**
- * @author parg
- *
- */
-
-import org.gudy.azureus2.platform.win32.access.*;
-
-public class 
-AEWin32AccessExceptionImpl
-	extends AEWin32AccessException
-{
-	
-	public
-	AEWin32AccessExceptionImpl(
-		String		operation,
-		String		message )
-	{
-		super(operation + ":" + message);
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessImpl.java org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessImpl.java
--- org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessImpl.java	2008-07-08 18:45:46.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessImpl.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,555 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access.impl;
-
-/**
- * @author parg
- *
- */
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.*;
-
-// don't use any core stuff in here as we need this access stub to be able to run in isolation
-
-import org.gudy.azureus2.core3.util.Constants;
-import org.gudy.azureus2.platform.PlatformManagerPingCallback;
-import org.gudy.azureus2.platform.win32.access.*;
-
-public class 
-AEWin32AccessImpl
-	implements AEWin32Access, AEWin32AccessCallback
-{
-	protected static AEWin32AccessImpl	singleton;
-	
-	public static synchronized AEWin32Access
-	getSingleton(
-		boolean	fully_initialise )
-	{
-		if ( singleton == null ){
-			
-			singleton = new AEWin32AccessImpl(fully_initialise);
-		}
-		
-		return( singleton );		
-	}
-	
-	private boolean	fully_initialise;
-	
-	private int	trace_id_next = new Random().nextInt();
-
-	private List	listeners = new ArrayList();
-	
-	protected
-	AEWin32AccessImpl(
-		boolean		_fully_initialise )
-	{
-		fully_initialise	= _fully_initialise;
-		
-		if ( isEnabled()){
-			
-			AEWin32AccessInterface.load( this, fully_initialise );
-		}
-	}
-	
-	public boolean
-	isEnabled()
-	{
-		return( AEWin32AccessInterface.isEnabled( fully_initialise ));
-	}
-	
-	public long
-	windowsMessage(
-		int		msg,
-		int		param1,
-		long	param2 )
-	{
-		int	type	= -1;
-		
-		if ( msg == AEWin32AccessInterface.WM_ENDSESSION ){
-		
-			type = AEWin32AccessListener.ET_SHUTDOWN;
-			
-		}else if ( msg == AEWin32AccessInterface.WM_POWERBROADCAST ){
-
-			if ( param1 == AEWin32AccessInterface.PBT_APMQUERYSUSPEND ){
-
-				type = AEWin32AccessListener.ET_SUSPEND;
-			
-			}else if ( param1 == AEWin32AccessInterface.PBT_APMRESUMESUSPEND ){
-				
-				type = AEWin32AccessListener.ET_RESUME;
-			}
-		}
-		
-		if ( type != -1 ){
-					
-			for (int i=0;i<listeners.size();i++){
-				
-				try{
-					((AEWin32AccessListener)listeners.get(i)).eventOccurred( type );
-					
-				}catch( Throwable e ){
-					
-					e.printStackTrace();
-				}
-			}
-		}
-		
-		return( -1 );
-	}
-	
-	public long
-	generalMessage(
-		String	str )
-	{	
-		return( 0 );
-	}
-	
-	public String
-	getVersion()
-	{
-		return( AEWin32AccessInterface.getVersion());		
-	}
-	
-	public String
-	readStringValue(
-		int		type,		
-		String	subkey,
-		String	value_name )
-	
-		throws AEWin32AccessException
-	{
-		return( AEWin32AccessInterface.readStringValue( type, subkey, value_name ));
-	}
-	
-	public void
-	writeStringValue(
-		int		type,		
-		String	subkey,
-		String	value_name,
-		String	value_value )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.writeStringValue( type, subkey, value_name, value_value );
-	}
-
-	
-	public int
-	readWordValue(
-		int		type,		
-		String	subkey,
-		String	value_name )
-	
-		throws AEWin32AccessException
-	{
-		return( AEWin32AccessInterface.readWordValue( type, subkey, value_name ));
-	}
-	
-	public void
-	writeWordValue(
-		int		type,		
-		String	subkey,
-		String	value_name,
-		int		value_value )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.writeWordValue( type, subkey, value_name, value_value );
-	}
-	
-	
-	public void
-	deleteKey(
-		int		type,
-		String	subkey )
-	
-		throws AEWin32AccessException
-	{
-		deleteKey( type, subkey, false );
-	}
-	
-	public void
-	deleteKey(
-		int		type,
-		String	subkey,
-		boolean	recursive )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.deleteKey( type, subkey, recursive );
-	}
-	
-	public void
-	deleteValue(
-		int			type,
-		String		subkey,
-		String		value_name )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.deleteValue( type, subkey, value_name );	
-	}
-	
-	public String
-	getUserAppData()
-	
-		throws AEWin32AccessException
-	{
-		String	app_data_key	= "software\\microsoft\\windows\\currentversion\\explorer\\shell folders";
-		String	app_data_name 	= "appdata";
-		
-		return(	readStringValue(
-					HKEY_CURRENT_USER,
-					app_data_key,
-					app_data_name ));
-
-	}
-
-	public String
-	getCommonAppData()
-	
-		throws AEWin32AccessException
-	{
-		String	app_data_key	= "software\\microsoft\\windows\\currentversion\\explorer\\shell folders";
-		String	app_data_name 	= "Common AppData";
-		
-		return(	readStringValue(
-					HKEY_LOCAL_MACHINE,
-					app_data_key,
-					app_data_name ));
-
-	}
-	
-	public String
-	getUserDocumentsDir()
-	
-		throws AEWin32AccessException
-	{
-		String	app_data_key	= "software\\microsoft\\windows\\currentversion\\explorer\\shell folders";
-		String	app_data_name 	= "personal";
-		
-		return(	readStringValue(
-					HKEY_CURRENT_USER,
-					app_data_key,
-					app_data_name ));
-
-	}
-
-	public String
-	getUserMusicDir()
-	
-		throws AEWin32AccessException
-	{
-		String	app_data_key	= "software\\microsoft\\windows\\currentversion\\explorer\\shell folders";
-		String	app_data_name 	= "my music";
-		
-		try {
-  		return(	readStringValue(
-  					HKEY_CURRENT_USER,
-  					app_data_key,
-  					app_data_name ));
-		} catch (AEWin32AccessException e) {
-			// Win98 doesn't have it
-  		String s = getUserDocumentsDir();
-  		if (s != null) {
-  			s += "\\My Music";
-  		}
-  		return s;
-		}
-
-	}
-
-
-	public String
-	getUserVideoDir()
-	
-		throws AEWin32AccessException
-	{
-		String	app_data_key	= "software\\microsoft\\windows\\currentversion\\explorer\\shell folders";
-		String	app_data_name 	= "my video";
-		
-		try {
-  		return(	readStringValue(
-  					HKEY_CURRENT_USER,
-  					app_data_key,
-  					app_data_name ));
-		} catch (AEWin32AccessException e) {
-			// Win98 doesn't have it
-  		String s = getUserDocumentsDir();
-  		if (s != null) {
-  			s += "\\My Video";
-  		}
-  		return s;
-		}
-
-	}
-
-	public String
-	getProgramFilesDir()
-	
-		throws AEWin32AccessException
-	{
-		String	app_data_key	= "software\\microsoft\\windows\\currentversion";
-		String	app_data_name 	= "ProgramFilesDir";
-		
-		return(	readStringValue(
-					HKEY_LOCAL_MACHINE,
-					app_data_key,
-					app_data_name ));
-	}
-	
-	
-	public String
-	getApplicationInstallDir(
-		String	app_name )
-		
-		throws AEWin32AccessException
-	{
-		String	res = "";
-		
-		try{
-			res = readStringValue(
-					HKEY_CURRENT_USER,
-					"software\\" + app_name,
-					null );
-			
-		}catch( AEWin32AccessException e ){
-			
-			res = readStringValue(
-					HKEY_LOCAL_MACHINE,
-					"software\\" + app_name,
-					null );
-						
-		}
-		
-		return( res );
-	}
-	
-	public void
-	createProcess(
-		String		command_line,
-		boolean		inherit_handles )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.createProcess( command_line, inherit_handles );
-	}	
-	
-	public void
-	moveToRecycleBin(
-		String	file_name )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.moveToRecycleBin( file_name );
-	}
-	
-	public void
-    copyFilePermissions(
-		String	from_file_name,
-		String	to_file_name )
-	
-		throws AEWin32AccessException
-	{
-		AEWin32AccessInterface.copyPermission( from_file_name, to_file_name ); 
-	}
-	
-	public boolean
-	testNativeAvailability(
-		String	name )
-	
-		throws AEWin32AccessException
-	{
-		return( AEWin32AccessInterface.testNativeAvailability( name ));
-	}
-	
-	public int shellExecute(String operation, String file, String parameters,
-			String directory, int SW_const) throws AEWin32AccessException {
-		return AEWin32AccessInterface.shellExecute(operation, file, parameters, 
-				directory, SW_const);
-	}
-	
-	public int 
-	shellExecuteAndWait(
-		String file, 
-		String params )
-	
-		throws AEWin32AccessException 
-	{
-		return( AEWin32AccessInterface.shellExecuteAndWait(file, params ));
-	}
-	
-	public void
-	traceRoute(
-		InetAddress								source_address,
-		InetAddress								target_address,
-		final PlatformManagerPingCallback		callback )
-	
-		throws AEWin32AccessException
-	{
-		traceRoute( source_address, target_address, false, callback );
-	}
-	
-	public void
-	ping(
-		InetAddress								source_address,
-		InetAddress								target_address,
-		final PlatformManagerPingCallback		callback )
-	
-		throws AEWin32AccessException
-	{
-		if ( Constants.compareVersions( getVersion(), "1.15" ) < 0 ){
-			
-			throw( new AEWin32AccessException( "Sorry, ping is broken in versions < 1.15" ));
-		}
-		
-		traceRoute( source_address, target_address, true, callback );
-	}
-	
-	protected void
-	traceRoute(
-		InetAddress						source_address,
-		InetAddress						target_address,
-		boolean							ping_mode,
-		PlatformManagerPingCallback		callback )
-	
-		throws AEWin32AccessException
-	{
-		int	trace_id;
-		
-		synchronized( this ){
-			
-			trace_id = trace_id_next++;
-		}
-		
-		AEWin32AccessCallback	cb = new traceRouteCallback( ping_mode, callback );
-	
-		AEWin32AccessInterface.traceRoute(
-				trace_id,
-				addressToInt( source_address ),
-				addressToInt( target_address ),
-				ping_mode?1:0,
-				cb );
-	}
-	
-	private int
-	addressToInt(
-		InetAddress	address )
-	{
-		byte[]	bytes = address.getAddress();
-		
-		int	resp = (bytes[0]<<24)&0xff000000 | (bytes[1] << 16)&0x00ff0000 | (bytes[2] << 8)&0x0000ff00 | bytes[3]&0x000000ff;
-			
-		return( resp );
-	}
-	
-	private InetAddress
-	intToAddress(
-		int		address )
-	{
-		byte[]	bytes = { (byte)(address>>24), (byte)(address>>16),(byte)(address>>8),(byte)address };
-		
-		try{
-			InetAddress	res = InetAddress.getByAddress(bytes);
-						
-			return( res );
-			
-		}catch( UnknownHostException e ){
-				
-			return( null );
-		}
-	}
-	
-	public void
-    addListener(
-    	AEWin32AccessListener		listener )
-    {
-    	listeners.add( listener );
-    }
-    
-    public void
-    removeListener(
-    	AEWin32AccessListener		listener )
-    {
-    	listeners.remove( listener );
-    }
-    
-    protected class
-    traceRouteCallback
-    	implements AEWin32AccessCallback
-	{
-    	private boolean							ping_mode;
-    	private PlatformManagerPingCallback		cb;
-	
-    	protected 
-    	traceRouteCallback(
-    		boolean							_ping_mode,
-    		PlatformManagerPingCallback		_cb )
-    	{
-    		ping_mode	= _ping_mode;
-    		cb			= _cb;
-    	}
-	
-		public long
-		windowsMessage(
-			int		msg,
-			int		param1,
-			long	param2 )
-		{
-			return(0);
-		}
-		
-		public long
-		generalMessage(
-			String	msg )
-		{
-			StringTokenizer	tok = new StringTokenizer( msg, "," );
-			
-			int	ttl 	= Integer.parseInt( tok.nextToken().trim());
-			int	time 	= -1;
-			
-			InetAddress	address;
-			
-			if ( tok.hasMoreTokens()){
-				
-				int	i_addr = Integer.parseInt( tok.nextToken().trim());
-				
-				address = intToAddress( i_addr );
-					
-				time = Integer.parseInt( tok.nextToken().trim());
-
-				//boolean is_udp = Integer.parseInt( tok.nextToken().trim()) == 1;
-				
-				// System.out.println( "udp = " + is_udp );
-			}else{
-				
-				address = null;
-			}
-						
-			return( cb.reportNode( ping_mode?-1:ttl, address, time )?1:0 );
-		}  	
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessInterface.java org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessInterface.java
--- org/gudy/azureus2/platform.orig/win32/access/impl/AEWin32AccessInterface.java	2008-07-08 18:45:46.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/AEWin32AccessInterface.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,249 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access.impl;
-
-/**
- * @author parg
- *
- */
-
-import org.gudy.azureus2.platform.win32.access.*;
-import org.gudy.azureus2.platform.win32.*;
-import org.gudy.azureus2.update.UpdaterUtils;
-
-public class 
-AEWin32AccessInterface 
-{
-	public static final int	HKEY_CLASSES_ROOT		= AEWin32Access.HKEY_CLASSES_ROOT;
-	public static final int	HKEY_CURRENT_CONFIG		= AEWin32Access.HKEY_CURRENT_CONFIG;
-	public static final int	HKEY_LOCAL_MACHINE		= AEWin32Access.HKEY_LOCAL_MACHINE;
-	public static final int	HKEY_CURRENT_USER		= AEWin32Access.HKEY_CURRENT_USER;
-
-	public static final int	WM_QUERYENDSESSION		= 0x0011;
-	public static final int	WM_ENDSESSION           = 0x0016;
-	public static final int	WM_POWERBROADCAST       = 0x0218;
-	public static final int	PBT_APMQUERYSUSPEND     = 0x0000;
-	public static final int	PBT_APMSUSPEND          = 0x0004;
-	public static final int	PBT_APMRESUMESUSPEND    = 0x0007;
-	
-	private static boolean						enabled;
-	private static boolean						enabled_set;
-	
-	private static AEWin32AccessCallback		cb;
-	
-	static{
-		System.loadLibrary( PlatformManagerImpl.DLL_NAME );
-	}
-	
-	protected static boolean
-	isEnabled(
-		boolean		check_if_disabled )
-	{
-		if ( !check_if_disabled ){
-			
-			return( true );
-		}
-		
-		if ( enabled_set ){
-			
-			return( enabled );
-		}
-		
-		try{
-				// protection against something really bad in the dll
-
-			enabled = !UpdaterUtils.disableNativeCode( getVersion());
-			
-			if ( !enabled ){
-			
-				System.err.println( "Native code has been disabled" );
-			}
-		}finally{
-			
-			enabled_set	= true;
-		}
-		
-		return( enabled );
-	}
-	
-	protected static void
-	load(
-		AEWin32AccessCallback	_callback,
-		boolean					_fully_initialise )
-	{	
-		cb = _callback;
-		
-		if ( _fully_initialise ){
-			
-			try{
-				initialise();
-				
-			}catch( Throwable e ){
-				
-				// get here when running 2400 java against old non-updated aereg.dll (for example)
-				// System.out.println( "Old aereg version, please update!" );
-			}
-		}
-	}
-	
-	public static long
-	callback(
-		int		msg,
-		int		param1,
-		long	param2 )
-	{
-		if ( cb == null ){
-						
-			return( -1 );
-			
-		}else{
-			
-			return( cb.windowsMessage( msg, param1, param2 ));
-		}
-	}
-	
-	protected static native void
-	initialise()
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	protected static native void
-	destroy()
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	protected static native String
-	getVersion();
-	
-	protected static native String
-	readStringValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	protected static native void
-	writeStringValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name,
-		String	value_value )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	protected static native int
-	readWordValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	protected static native void
-	writeWordValue(
-		int		type,		// HKEY type from above
-		String	subkey,
-		String	value_name,
-		int		value_value )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-
-	protected static native void
-	deleteKey(
-		int		type,
-		String	subkey,
-		boolean	recursive )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	protected static native void
-	deleteValue(
-		int		type,
-		String	subkey,
-		String 	value_namae )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	public static native void
-	createProcess(
-		String		command_line,
-		boolean		inherit_handles )
-	
-		throws AEWin32AccessException;
-	
-	public static native void
-	moveToRecycleBin(
-		String		file_name )
-	
-		throws AEWin32AccessException;
-	
-	public static native void
-	copyPermission(
-		String		from_file_name,
-		String		to_file_name )
-	
-		throws AEWin32AccessException;
-	
-	public static native boolean
-	testNativeAvailability(
-		String	name )
-	
-		throws AEWin32AccessException;
-	
-	/*
-	public static native void
-	ping(
-		String		address )
-	
-		throws AEWin32AccessException;
-	*/
-	
-	public static native void
-	traceRoute(
-		int						trace_id,
-		int						source_address,
-		int						target_address,
-		int						pice_mode,
-		AEWin32AccessCallback	callback )
-	
-		throws AEWin32AccessException;
-
-	public static native int 
-	shellExecute(
-		String 		operation, 
-		String 		file,
-		String 		parameters, 
-		String 		directory, 
-		int 		sw_const )
-	
-		throws AEWin32AccessExceptionImpl;
-	
-	public static native int 
-	shellExecuteAndWait(
-		String 		file,
-		String 		parameters )
-	
-		throws AEWin32AccessExceptionImpl;
-}
Binary files org/gudy/azureus2/platform.orig/win32/access/impl/Debug/aereg.dll and org/gudy/azureus2/platform/win32/access/impl/Debug/aereg.dll differ
Binary files org/gudy/azureus2/platform.orig/win32/access/impl/Debug/aereg.lib and org/gudy/azureus2/platform/win32/access/impl/Debug/aereg.lib differ
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/generate_ini.bat org/gudy/azureus2/platform/win32/access/impl/generate_ini.bat
--- org/gudy/azureus2/platform.orig/win32/access/impl/generate_ini.bat	2006-11-09 17:25:10.000000000 -0800
+++ org/gudy/azureus2/platform/win32/access/impl/generate_ini.bat	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-c:\j2sdk1.4.2_04\bin\javah -d . -classpath ..\..\..\..\..\..\.. org.gudy.azureus2.platform.win32.access.impl.AEWin32AccessInterface
\ No newline at end of file
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h org/gudy/azureus2/platform/win32/access/impl/org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h
--- org/gudy/azureus2/platform.orig/win32/access/impl/org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h	2008-07-08 18:45:46.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,164 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface */
-
-#ifndef _Included_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
-#define _Included_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CLASSES_ROOT
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CLASSES_ROOT 1L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CURRENT_CONFIG
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CURRENT_CONFIG 2L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_LOCAL_MACHINE
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_LOCAL_MACHINE 3L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CURRENT_USER
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_HKEY_CURRENT_USER 4L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_WM_QUERYENDSESSION
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_WM_QUERYENDSESSION 17L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_WM_ENDSESSION
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_WM_ENDSESSION 22L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_WM_POWERBROADCAST
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_WM_POWERBROADCAST 536L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_PBT_APMQUERYSUSPEND
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_PBT_APMQUERYSUSPEND 0L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_PBT_APMSUSPEND
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_PBT_APMSUSPEND 4L
-#undef org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_PBT_APMRESUMESUSPEND
-#define org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_PBT_APMRESUMESUSPEND 7L
-/* Inaccessible static: enabled */
-/* Inaccessible static: enabled_set */
-/* Inaccessible static: cb */
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    initialise
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_initialise
-  (JNIEnv *, jclass);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    destroy
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_destroy
-  (JNIEnv *, jclass);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    getVersion
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_getVersion
-  (JNIEnv *, jclass);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    readStringValue
- * Signature: (ILjava/lang/String;Ljava/lang/String;)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readStringValue
-  (JNIEnv *, jclass, jint, jstring, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    writeStringValue
- * Signature: (ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeStringValue
-  (JNIEnv *, jclass, jint, jstring, jstring, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    readWordValue
- * Signature: (ILjava/lang/String;Ljava/lang/String;)I
- */
-JNIEXPORT jint JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_readWordValue
-  (JNIEnv *, jclass, jint, jstring, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    writeWordValue
- * Signature: (ILjava/lang/String;Ljava/lang/String;I)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_writeWordValue
-  (JNIEnv *, jclass, jint, jstring, jstring, jint);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    deleteKey
- * Signature: (ILjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteKey
-  (JNIEnv *, jclass, jint, jstring, jboolean);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    deleteValue
- * Signature: (ILjava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_deleteValue
-  (JNIEnv *, jclass, jint, jstring, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    createProcess
- * Signature: (Ljava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_createProcess
-  (JNIEnv *, jclass, jstring, jboolean);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    moveToRecycleBin
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_moveToRecycleBin
-  (JNIEnv *, jclass, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    copyPermission
- * Signature: (Ljava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_copyPermission
-  (JNIEnv *, jclass, jstring, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    testNativeAvailability
- * Signature: (Ljava/lang/String;)Z
- */
-JNIEXPORT jboolean JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_testNativeAvailability
-  (JNIEnv *, jclass, jstring);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    traceRoute
- * Signature: (IIIILorg/gudy/azureus2/platform/win32/access/impl/AEWin32AccessCallback;)V
- */
-JNIEXPORT void JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_traceRoute
-  (JNIEnv *, jclass, jint, jint, jint, jint, jobject);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    shellExecute
- * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)I
- */
-JNIEXPORT jint JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecute
-  (JNIEnv *, jclass, jstring, jstring, jstring, jstring, jint);
-
-/*
- * Class:     org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface
- * Method:    shellExecuteAndWait
- * Signature: (Ljava/lang/String;Ljava/lang/String;)I
- */
-JNIEXPORT jint JNICALL Java_org_gudy_azureus2_platform_win32_access_impl_AEWin32AccessInterface_shellExecuteAndWait
-  (JNIEnv *, jclass, jstring, jstring);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
Binary files org/gudy/azureus2/platform.orig/win32/access/impl/Release/aereg.dll and org/gudy/azureus2/platform/win32/access/impl/Release/aereg.dll differ
Binary files org/gudy/azureus2/platform.orig/win32/access/impl/Release/aereg.lib and org/gudy/azureus2/platform/win32/access/impl/Release/aereg.lib differ
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/StdAfx.cpp org/gudy/azureus2/platform/win32/access/impl/StdAfx.cpp
--- org/gudy/azureus2/platform.orig/win32/access/impl/StdAfx.cpp	2004-04-17 10:22:32.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/StdAfx.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,8 +0,0 @@
-// stdafx.cpp : source file that includes just the standard includes
-//	aereg.pch will be the pre-compiled header
-//	stdafx.obj will contain the pre-compiled type information
-
-#include "stdafx.h"
-
-// TODO: reference any additional headers you need in STDAFX.H
-// and not in this file
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/StdAfx.h org/gudy/azureus2/platform/win32/access/impl/StdAfx.h
--- org/gudy/azureus2/platform.orig/win32/access/impl/StdAfx.h	2004-04-17 10:22:32.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/StdAfx.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,24 +0,0 @@
-// stdafx.h : include file for standard system include files,
-//  or project specific include files that are used frequently, but
-//      are changed infrequently
-//
-
-#if !defined(AFX_STDAFX_H__EB4D9027_DB05_4618_9310_821A191B789B__INCLUDED_)
-#define AFX_STDAFX_H__EB4D9027_DB05_4618_9310_821A191B789B__INCLUDED_
-
-#if _MSC_VER > 1000
-#pragma once
-#endif // _MSC_VER > 1000
-
-
-// Insert your headers here
-#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
-
-#include <windows.h>
-
-// TODO: reference additional headers your program requires here
-
-//{{AFX_INSERT_LOCATION}}
-// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
-
-#endif // !defined(AFX_STDAFX_H__EB4D9027_DB05_4618_9310_821A191B789B__INCLUDED_)
diff -urN org/gudy/azureus2/platform.orig/win32/access/impl/Test.java org/gudy/azureus2/platform/win32/access/impl/Test.java
--- org/gudy/azureus2/platform.orig/win32/access/impl/Test.java	2008-07-08 18:45:46.000000000 -0700
+++ org/gudy/azureus2/platform/win32/access/impl/Test.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,150 +0,0 @@
-/*
- * Created on Apr 16, 2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32.access.impl;
-
-/**
- * @author parg
- *
- */
-
-import java.net.InetAddress;
-
-import org.gudy.azureus2.platform.PlatformManagerPingCallback;
-
-public class 
-Test 
-{
-	public static void
-	main(
-		String[]	args )
-	{
-		try{
-			/*
-			AEWin32Access access = AEWin32Manager.getAccessor();
-			
-			String	app_data = access.getUserAppData();
-			
-			System.out.println( "AppData = " + app_data );
-
-			String az_home = access.getApplicationInstallDir("azureus");
-			
-			File	az_exe = new File( az_home + File.separator + "Azureus.exe" ).getAbsoluteFile();
-			
-			if ( az_exe.exists()){
-				
-				//<Nolar> 	WriteRegStr HKCR ".torrent" "" "BitTorrent"
-				//<Nolar> 	WriteRegStr HKCR "BitTorrent" "" "Bittorrent File"
-				//<Nolar> 	WriteRegStr HKCR "BitTorrent\shell" "" "open"
-				//<Nolar> 	WriteRegStr HKCR "BitTorrent\DefaultIcon" "" $INSTDIR\Azureus.exe,1
-				//<Nolar>   	WriteRegStr HKCR "BitTorrent\shell\open\command" "" '"$INSTDIR\Azureus.exe" "%1"'
-				//<Nolar>   	WriteRegStr HKCR "BitTorrent\Content Type" "" "application/x-bittorrent"
-				
-				System.out.println( "current = " + 
-						access.readStringValue( 	
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						"BitTorrent\\shell\\open\\command",
-						"" ));
-				
-				access.deleteKey( 	AEWin32Access.HKEY_CLASSES_ROOT,
-									".torrent" );
-			
-				access.deleteKey( 	AEWin32Access.HKEY_CLASSES_ROOT,
-									"BitTorrent",
-									true );
-			
-				access.writeStringValue( 	AEWin32Access.HKEY_CLASSES_ROOT,
-											".torrent",
-											"",
-											"BitTorrent" );
-				
-				access.writeStringValue( 	
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						"BitTorrent",
-						"",
-						"Bittorrent File" );
-
-				access.writeStringValue( 	
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						"BitTorrent\\shell",
-						"",
-						"open" );
-				
-				access.writeStringValue( 	
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						"BitTorrent\\DefaultIcon",
-						"",
-						az_exe.toString() + ",1" );
-				
-				access.writeStringValue( 	
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						"BitTorrent\\shell\\open\\command",
-						"",
-						"\"" + az_exe.toString() + "\" \"%1\"" );
-				
-				access.writeStringValue( 	
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						"BitTorrent\\Content Type" ,
-						"",
-						"application/x-bittorrent" );
-				
-			}else{
-				
-				System.out.println( "can't find Azureus.exe");
-			}
-		*/
-			
-			//AEWin32AccessInterface.copyPermission( "C:\\temp\\fred", "C:\\temp\\bill" );
-			
-			/*
-			AEWin32AccessImpl.getSingleton( false ).traceRoute(
-					InetAddress.getByName( "192.168.1.143" ),
-					InetAddress.getByName( "www.google.com"),
-					new PlatformManagerPingCallback()
-					{
-						public boolean
-						reportNode(
-							int				distance,
-							InetAddress		address,
-							int				millis )
-						{
-							System.out.println( distance + ": " + address + " - " + millis );
-							
-							return( true );
-						}
-					});
-			*/
-			
-			// AEWin32AccessInterface.ping( "www.google.com" );
-			
-			int res = AEWin32AccessImpl.getSingleton( false ).shellExecuteAndWait(
-				"c:\\temp\\3110\\Vuze_3.1.1.0_windows.exe",
-				"-VFORCE_LAUNCH=1" );
-			
-			System.out.println( "res=" + res );
-			
-		}catch( Throwable e ){
-			
-			e.printStackTrace();
-		}
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/win32/PlatformManagerImpl.java org/gudy/azureus2/platform/win32/PlatformManagerImpl.java
--- org/gudy/azureus2/platform.orig/win32/PlatformManagerImpl.java	2008-10-22 11:12:30.000000000 -0700
+++ org/gudy/azureus2/platform/win32/PlatformManagerImpl.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,1214 +0,0 @@
-/*
- * Created on 18-Apr-2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32;
-
-/**
- * @author parg
- *
- */
-
-import java.io.File;
-import java.net.InetAddress;
-import java.util.*;
-
-import org.gudy.azureus2.core3.config.COConfigurationManager;
-import org.gudy.azureus2.core3.logging.LogAlert;
-import org.gudy.azureus2.core3.logging.Logger;
-import org.gudy.azureus2.core3.util.*;
-import org.gudy.azureus2.platform.*;
-import org.gudy.azureus2.platform.win32.access.AEWin32Access;
-import org.gudy.azureus2.platform.win32.access.AEWin32AccessListener;
-import org.gudy.azureus2.platform.win32.access.AEWin32Manager;
-
-import org.gudy.azureus2.plugins.platform.PlatformManagerException;
-
-
-public class 
-PlatformManagerImpl
-	implements PlatformManager, AEWin32AccessListener
-{
-	public static final int			RT_NONE		= 0;
-	public static final int			RT_AZ 		= 1;
-	public static final int			RT_OTHER 	= 2;
-	
-	public static final String					DLL_NAME = "aereg";
-	
-	public static final String				VUZE_ASSOC		= "Vuze";
-	public static final String				NEW_MAIN_ASSOC	= "Azureus";
-	public static final String				OLD_MAIN_ASS0C	= "BitTorrent";
-	
-	private static boolean					initialising;
-	private static boolean					init_tried;
-	
-	private static PlatformManagerImpl		singleton;
-	private static AEMonitor				class_mon	= new AEMonitor( "PlatformManager");
-
-	private final Set capabilitySet = new HashSet();
-
-	private List	listeners = new ArrayList();
-	
-	public static PlatformManagerImpl
-	getSingleton()
-	
-		throws PlatformManagerException	
-	{
-		try{
-			class_mon.enter();
-		
-			if ( singleton != null ){
-				
-				return( singleton );
-			}
-			
-			try{	
-				if ( initialising ){
-					
-					System.err.println( "PlatformManager: recursive entry during initialisation" );
-				}
-				
-				initialising	= true;
-				
-				if ( !init_tried ){
-					
-					init_tried	= true;
-					
-					try{
-						singleton	= new PlatformManagerImpl();
-						
-							// gotta separate this so that a recursive call due to config access during
-							// patching finds the singleton 
-						
-						singleton.applyPatches();
-						
-					}catch( PlatformManagerException e ){
-						
-						throw( e );
-						
-					}catch( Throwable e ){
-												
-						if ( e instanceof PlatformManagerException ){
-							
-							throw((PlatformManagerException)e);
-						}
-						
-						throw( new PlatformManagerException( "Win32Platform: failed to initialise", e ));
-					}
-				}
-			}finally{
-				
-				initialising	= false;
-			}
-			
-			return( singleton );
-			
-		}finally{
-			
-			class_mon.exit();
-		}
-	}
-	
-	private final AEWin32Access		access;
-
-	private final String			app_name;
-	private final String			app_exe_name;
-	private File					az_exe;
-	private boolean					az_exe_checked;
-
-	protected
-	PlatformManagerImpl()
-	
-		throws PlatformManagerException
-	{
-		access	= AEWin32Manager.getAccessor( true );
-		
-		access.addListener( this );
-		
-		app_name		= SystemProperties.getApplicationName();
-		
-		app_exe_name	= app_name + ".exe";
-		
-        initializeCapabilities();
-	}
-
-    private void
-    initializeCapabilities()
-    {
-    	if ( access.isEnabled()){
-    		
-	        capabilitySet.add(PlatformManagerCapabilities.CreateCommandLineProcess);
-	        capabilitySet.add(PlatformManagerCapabilities.GetUserDataDirectory);
-	        capabilitySet.add(PlatformManagerCapabilities.RecoverableFileDelete);
-	        capabilitySet.add(PlatformManagerCapabilities.RegisterFileAssociations);
-	        capabilitySet.add(PlatformManagerCapabilities.ShowFileInBrowser);
-	        capabilitySet.add(PlatformManagerCapabilities.GetVersion);
-	        capabilitySet.add(PlatformManagerCapabilities.SetTCPTOSEnabled);
-	        capabilitySet.add(PlatformManagerCapabilities.ComputerIDAvailability);
-	        
-	        
-	        if ( Constants.compareVersions( access.getVersion(), "1.11" ) >= 0 &&
-	        		!Constants.isWindows9598ME ){
-	        	
-	            capabilitySet.add(PlatformManagerCapabilities.CopyFilePermissions);
-	            
-	        }
-	        
-	        if ( Constants.compareVersions( access.getVersion(), "1.12" ) >= 0 ){
-	        	
-	            capabilitySet.add(PlatformManagerCapabilities.TestNativeAvailability);
-	        }
-	        
-	        if ( Constants.compareVersions( access.getVersion(), "1.14" ) >= 0 ){
-	        	
-	            capabilitySet.add(PlatformManagerCapabilities.TraceRouteAvailability);
-	        }
-
-	        if ( Constants.compareVersions( access.getVersion(), "1.15" ) >= 0 ){
-	        	
-	            capabilitySet.add(PlatformManagerCapabilities.PingAvailability);
-	        }
-
-    	}else{
-    		
-    			// disabled -> only available capability is that to get the version
-    			// therefore allowing upgrade
-    		
-	        capabilitySet.add(PlatformManagerCapabilities.GetVersion);
-    	}
-    }
-
-    protected void
-	applyPatches()
-	{
-		try{
-			File	exe_loc = getApplicationEXELocation();
-			
-			String	az_exe_string = exe_loc.toString();
-			
-			//int	icon_index = getIconIndex();
-			
-			String	current = 
-				access.readStringValue(
-					AEWin32Access.HKEY_CLASSES_ROOT,
-					NEW_MAIN_ASSOC + "\\DefaultIcon",
-					"" );
-
-			//System.out.println( "current = " + current );
-			
-			String	target = az_exe_string + "," + getIconIndex();
-			
-			//System.out.println( "target = " + target );
-			
-				// only patch if Azureus.exe in there
-			
-			if ( current.indexOf( app_exe_name ) != -1 && !current.equals(target)){
-				
-				writeStringToHKCRandHKCU( 	
-						NEW_MAIN_ASSOC + "\\DefaultIcon",
-						"",
-						target );
-			}
-		}catch( Throwable e ){
-			
-			//e.printStackTrace();
-		}
-		
-			// one off fix of permissions in app dir
-		
-		if ( 	hasCapability( PlatformManagerCapabilities.CopyFilePermissions ) &&
-				!COConfigurationManager.getBooleanParameter( "platform.win32.permfixdone2", false )){
-
-			try{
-				
-				String	str = SystemProperties.getApplicationPath();
-				
-				if ( str.endsWith(File.separator)){
-					
-					str = str.substring(0,str.length()-1);
-				}
-				
-				fixPermissions( new File( str ), new File( str ));
-				
-			}catch( Throwable e ){
-				
-			}finally{
-				
-				COConfigurationManager.setParameter( "platform.win32.permfixdone2", true );
-			}
-		}
-	}
-	
-    protected void
-    fixPermissions(
-    	File		parent,
-    	File		dir )
-    
-    	throws PlatformManagerException
-    {
-    	File[]	files = dir.listFiles();
-    	
-    	if ( files == null ){
-    		
-    		return;
-    	}
-    	
-    	for (int i=0;i<files.length;i++){
-    		
-    		File	file = files[i];
-    		   	   		
-    		if ( file.isFile()){
-    			
-    			copyFilePermissions( parent.getAbsolutePath(), file.getAbsolutePath());
-    		}
-    	}
-    }
-    
-	protected int
-	getIconIndex()
-	
-		throws PlatformManagerException
-	{
-		/*
-		File	exe_loc = getAureusEXELocation();
-		
-		long	size = exe_loc.length();
-		
-		boolean	old_exe = size < 250000;
-		
-		return( old_exe?0:1);
-		*/
-		
-		// weird, seems like it should be 0 for old and new
-		
-		return( 0 );
-	}
-	
-	public String
-	getVersion()
-	{
-		return( access.getVersion());
-	}
-	
-	protected File
-	getApplicationEXELocation()
-		throws PlatformManagerException
-	{
-		if ( az_exe == null ){
-			
-			try{
-			
-				String az_home;
-				
-				// Try the app dir first, because we may not be using the one in the registry
-				az_home = SystemProperties.getApplicationPath();		
-				
-				az_exe = new File(az_home + File.separator + app_exe_name).getAbsoluteFile();
-
-				if (!az_exe.exists()) {
-					try {
-						az_home = access.getApplicationInstallDir( app_name );
-
-						az_exe = new File(az_home + File.separator + app_exe_name).getAbsoluteFile();
-
-						if (!az_exe.exists()) {
-
-							throw (new PlatformManagerException(app_exe_name
-									+ " not found in " + az_home + ", please re-install"));
-						}
-					} catch (Throwable e) {
-					}
-				}
-								
-				if ( !az_exe.exists()){
-					
-					String	msg = app_exe_name + " not found in " + az_home + " - can't check file associations. Please re-install " + app_name;
-					
-					az_exe = null;
-					
-					if (!az_exe_checked){
-					
-						Logger.log(new LogAlert(LogAlert.UNREPEATABLE, LogAlert.AT_WARNING,
-								msg));
-					}
-					
-					throw( new PlatformManagerException( msg ));
-				}
-			}finally{
-				
-				az_exe_checked	= true;
-			}
-		}
-		
-		return( az_exe );
-	}
-	
-	public int
-	getPlatformType()
-	{
-		return( PT_WINDOWS );
-	}
-	
-	public String
-	getUserDataDirectory()
-	
-		throws PlatformManagerException
-	{
-		try{
-			return access.getUserAppData() + SystemProperties.SEP + app_name + SystemProperties.SEP;
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to read registry details", e ));
-		}		
-	}
-	
-	public File
-	getLocation(
-		long	location_id )
-	
-		throws PlatformManagerException
-	{
-	    if ( location_id == LOC_USER_DATA ){
-	    	
-	    	return(new File(getUserDataDirectory()));
-	    	
-	    }else if ( location_id == LOC_MUSIC ){
-	    	
-	    	try{
-	    		
-		    	return(new File(access.getUserMusicDir()));
-		    	
-	    	}catch( Throwable e ){
-	    		
-				throw( new PlatformManagerException( "Failed to read registry details", e ));
-	    	}
-	    } else if (location_id == LOC_DOCUMENTS) {
-	    	try{
-	    		
-		    	return(new File(access.getUserDocumentsDir()));
-		    	
-	    	}catch( Throwable e ){
-	    		
-				throw( new PlatformManagerException( "Failed to read registry details", e ));
-	    	}
-	    } else if (location_id == LOC_VIDEO) {
-	    	try{
-	    		
-		    	return(new File(access.getUserVideoDir()));
-		    	
-	    	}catch( Throwable e ){
-	    		
-				throw( new PlatformManagerException( "Failed to read registry details", e ));
-	    	}
-	    }else{
-	    	
-	    	return( null );
-	    }
-	}
-	
-	public String
-	getApplicationCommandLine()
-	{
-		try{
-			return( getApplicationEXELocation().toString());
-			
-		}catch( Throwable e ){
-			
-			return( null );
-		}
-	}
-	
-	public boolean
-	isApplicationRegistered()
-	
-		throws PlatformManagerException
-	{
-			// all this stuff needs the exe location so bail out early if unavailable
-		
-		File exe_loc = getApplicationEXELocation();
-		
-		if ( exe_loc.exists()){
-			
-			checkExeKey( exe_loc );
-		}
-		
-		try{
-				// always trigger magnet reg here if not owned so old users get it...
-			
-			if ( getAdditionalFileTypeRegistrationDetails( "Magnet", ".magnet" ) == RT_NONE ){
-		
-				registerMagnet();
-			}
-		}catch( Throwable e ){
-			
-			Debug.printStackTrace(e);
-		}
-		
-		try{
-				// always trigger magnet reg here if not owned so old users get it...
-			
-			if ( getAdditionalFileTypeRegistrationDetails( "DHT", ".dht" ) == RT_NONE ){
-		
-				registerDHT();
-			}
-		}catch( Throwable e ){
-			
-			Debug.printStackTrace(e);
-		}
-	
-		if ( isAdditionalFileTypeRegistered( OLD_MAIN_ASS0C, ".torrent" )){
-			
-			unregisterAdditionalFileType( OLD_MAIN_ASS0C, ".torrent" );
-			
-			registerAdditionalFileType( NEW_MAIN_ASSOC, Constants.APP_NAME + " Download", ".torrent", "application/x-bittorrent" );
-		}
-		
-		boolean	reg = isAdditionalFileTypeRegistered( NEW_MAIN_ASSOC, ".torrent" );
-		
-			// one off auto registration on new install
-		
-		if ( !reg && !COConfigurationManager.getBooleanParameter( "platform.win32.autoregdone", false )){
-			
-			registerAdditionalFileType( NEW_MAIN_ASSOC, Constants.APP_NAME + " Download", ".torrent", "application/x-bittorrent" );
-
-			COConfigurationManager.setParameter( "platform.win32.autoregdone", true );
-			
-			reg	= true;
-		}
-		
-			// always register .vuze association
-		
-		boolean	vuze_reg = isAdditionalFileTypeRegistered( VUZE_ASSOC, ".vuze" );
-
-		if ( !vuze_reg ){
-			
-			registerAdditionalFileType( VUZE_ASSOC, "Vuze File", ".vuze", "application/x-vuze" );
-		}
-		
-		return( reg );
-	}
-	
-	protected void
-	checkExeKey(
-		File		exe )
-	{
-		checkExeKey( AEWin32Access.HKEY_CURRENT_USER, exe );
-		checkExeKey( AEWin32Access.HKEY_LOCAL_MACHINE, exe );
-	}
-	
-	protected void
-	checkExeKey(
-		int			hkey,
-		File		exe )
-	{
-		String	exe_str = exe.getAbsolutePath();
-		
-		String str = null;
-		
-		try{
-			str = access.readStringValue( hkey, "software\\" + app_name, "exec" );
-
-		}catch( Throwable e ){
-		}
-		
-		try{
-			if ( str == null || !str.equals( exe_str )){
-				
-				access.writeStringValue( hkey, "software\\" + app_name,	"exec",	exe_str );
-			}
-		}catch( Throwable e ){
-		}
-	}
-	
-	public boolean
-	isAdditionalFileTypeRegistered(
-		String		name,
-		String		type )
-	
-		throws PlatformManagerException
-	{
-		return( getAdditionalFileTypeRegistrationDetails( name, type ) == RT_AZ );
-	}
-	
-	public int
-	getAdditionalFileTypeRegistrationDetails(
-		String		name,
-		String		type )
-	
-		throws PlatformManagerException
-	{
-
-		String	az_exe_str;
-		
-		try{
-			az_exe_str = getApplicationEXELocation().toString();
-		
-		}catch( Throwable e ){
-			
-			return( RT_NONE );
-		}
-		
-		try{
-			String	test1 = 
-				access.readStringValue( 	
-					AEWin32Access.HKEY_CLASSES_ROOT,
-					name + "\\shell\\open\\command",
-					"" );
-			
-			if ( !test1.equals( "\"" + az_exe_str + "\" \"%1\"" )){
-				
-				return( test1.length() ==0?RT_NONE:RT_OTHER );
-			}
-			
-			String test2 =
-				access.readStringValue(
-						AEWin32Access.HKEY_CLASSES_ROOT,
-						type,
-						"");
-			if ( !test2.equals( NEW_MAIN_ASSOC )) {
-				return test2.length() == 0 ? RT_NONE : RT_OTHER;
-			}
-
-				// MRU list is just that, to remove the "always open with" we need to kill
-				// the "application" entry, if it exists
-			
-			try{
-				String	always_open_with = 
-					access.readStringValue( 
-						AEWin32Access.HKEY_CURRENT_USER,
-						"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\" + type,
-						"Application" );
-				
-				//System.out.println( "mru_list = " + mru_list );
-
-				if ( always_open_with.length() > 0 ){
-				
-					// AZ is default so if this entry exists it denotes another (non-AZ) app
-					
-					return( RT_OTHER );
-				}
-			}catch( Throwable e ){
-				
-				// e.printStackTrace();
-				
-				// failure means things are OK
-			}
-			
-			/*
-			try{
-				String	mru_list = 
-					access.readStringValue( 
-						AEWin32Access.HKEY_CURRENT_USER,
-						"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.torrent\\OpenWithList",
-						"MRUList" );
-				
-				//System.out.println( "mru_list = " + mru_list );
-
-				if ( mru_list.length() > 0 ){
-				
-					String	mru = 
-						access.readStringValue( 
-							AEWin32Access.HKEY_CURRENT_USER,
-							"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.torrent\\OpenWithList",
-							"" + mru_list.charAt(0) );
-					
-					//System.out.println( "mru = " + mru );
-					
-					return( mru.equalsIgnoreCase(app_exe_name));
-				}
-			}catch( Throwable e ){
-				
-				// e.printStackTrace();
-				
-				// failure means things are OK
-			}
-			*/
-			
-			return( RT_AZ );
-			
-		}catch( Throwable e ){
-			
-			if ( 	e.getMessage() == null || 
-					e.getMessage().indexOf("RegOpenKey failed") == -1 ){
-				
-				Debug.printStackTrace( e );
-			}
-
-			return( RT_NONE );
-		}
-	}
-	
-	public void
-	registerApplication()
-	
-		throws PlatformManagerException
-	{
-		registerMagnet();
-		
-		registerDHT();
-		
-		registerAdditionalFileType( NEW_MAIN_ASSOC, Constants.APP_NAME + " Download", ".torrent", "application/x-bittorrent" );
-		
-		registerAdditionalFileType( VUZE_ASSOC, "Vuze File", ".vuze", "application/x-vuze" );
-	}
-	
-	protected void
-	registerMagnet()
-	{
-		try{
-			registerAdditionalFileType( 
-				"Magnet", 
-				"Magnet URI", 
-				".magnet", 
-				"application/x-magnet",
-				true );
-			
-		}catch( Throwable e ){
-			
-			Debug.printStackTrace(e);
-		}
-	}
-	
-	protected void
-	registerDHT()
-	{
-		try{
-			registerAdditionalFileType( 
-				"DHT", 
-				"DHT URI", 
-				".dht", 
-				"application/x-dht",
-				true );
-			
-		}catch( Throwable e ){
-			
-			Debug.printStackTrace(e);
-		}
-	}
-	
-	public void
-	registerAdditionalFileType(
-		String		name,				// e.g. "Azureus"
-		String		description,		// e.g. "BitTorrent File"
-		String		type,				// e.g. ".torrent"
-		String		content_type )		// e.g. "application/x-bittorrent"
-		
-		throws PlatformManagerException
-	{
-		registerAdditionalFileType( name, description, type, content_type, false );
-	}
-	
-	public void
-	registerAdditionalFileType(
-		String		name,				
-		String		description,		
-		String		type,				
-		String		content_type,
-		boolean		url_protocol)		
-		
-		throws PlatformManagerException
-	{
-		// 	WriteRegStr HKCR ".torrent" "" "Azureus"
-		// 	WriteRegStr HKCR "Azureus" "" "Vuze Torrent"
-		// 	WriteRegStr HKCR "Azureus\shell" "" "open"
-		// 	WriteRegStr HKCR "Azureus\DefaultIcon" "" $INSTDIR\Azureus.exe,1
-		// 	WriteRegStr HKCR "Azureus\shell\open\command" "" '"$INSTDIR\Azureus.exe" "%1"'
-		// 	WriteRegStr HKCR "Azureus\Content Type" "" "application/x-bittorrent"
-		
-
-		try{
-			String	az_exe_string	= getApplicationEXELocation().toString();
-			
-			unregisterAdditionalFileType( name, type );
-
-			writeStringToHKCRandHKCU(
-					type,
-					"",
-					name );
-		
-			writeStringToHKCRandHKCU(
-					type,
-					"Content Type",
-					content_type );
-		
-			writeStringToHKCRandHKCU(
-					"MIME\\Database\\Content Type\\" + content_type,
-					"Extension",
-					type );
-		
-			writeStringToHKCRandHKCU(
-					name,
-					"",
-					description );
-			
-			writeStringToHKCRandHKCU(
-					name + "\\shell",
-					"",
-					"open" );
-			
-			writeStringToHKCRandHKCU(
-					name + "\\DefaultIcon",
-					"",
-					az_exe_string + "," + getIconIndex());
-			
-			writeStringToHKCRandHKCU(
-					name + "\\shell\\open\\command",
-					"",
-					"\"" + az_exe_string + "\" \"%1\"" );
-					
-			writeStringToHKCRandHKCU(
-					name,
-					"Content Type",
-					content_type );
-			
-			if ( url_protocol ){
-				
-				writeStringToHKCRandHKCU(
-						name,
-						"URL Protocol",
-						"" );
-			}
-			
-		}catch( PlatformManagerException e ){
-			
-			throw(e );
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to write registry details", e ));
-		}
-	}
-	
-	private void writeStringToHKCRandHKCU(String subkey, String name, String value) {
-		// HKCU will most likely fail on Vista due to permissions
-		try {
-			access.writeStringValue(AEWin32Access.HKEY_CLASSES_ROOT, subkey, name, value);
-		} catch (Throwable e) {
-			if (!Constants.isWindowsVista) {
-				Debug.out(e);
-			}
-		}
-
-		try {
-			access.writeStringValue(AEWin32Access.HKEY_CURRENT_USER,
-					"Software\\Classes\\" + subkey, name, value);
-		} catch (Throwable e) {
-			Debug.out(e);
-		}
-	}
-	
-	public void
-	unregisterAdditionalFileType(
-		String		name,				// e.g. "Azureus"
-		String		type )				// e.g. ".torrent"
-		
-		throws PlatformManagerException
-	{
-		try{
-			try{
-		
-				access.deleteValue( 	
-					AEWin32Access.HKEY_CURRENT_USER,
-					"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\" + type,
-					"Application" );
-				
-			}catch( Throwable e ){
-				
-				// e.printStackTrace();
-			}
-			
-			try{
-				access.deleteKey( 	
-					AEWin32Access.HKEY_CLASSES_ROOT,
-					type );
-				
-			}catch( Throwable e ){
-				
-				// Debug.printStackTrace( e );
-			}
-			
-			try{
-				access.deleteKey( 	
-					AEWin32Access.HKEY_CLASSES_ROOT,
-					name,
-					true );
-				
-			}catch( Throwable e ){
-				
-				// Debug.printStackTrace( e );
-			}
-
-			try{
-				access.deleteKey( 	
-					AEWin32Access.HKEY_CURRENT_USER,
-					"Software\\Classes\\" + type );
-				
-			}catch( Throwable e ){
-				
-				// Debug.printStackTrace( e );
-			}
-			
-			try{
-				access.deleteKey( 	
-					AEWin32Access.HKEY_CURRENT_USER,
-					"Software\\Classes\\" + name,
-					true );
-				
-			}catch( Throwable e ){
-				
-				// Debug.printStackTrace( e );
-			}
-
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to delete registry details", e ));
-		}
-	}
-	
-	public void
-	createProcess(
-		String	command_line,
-		boolean	inherit_handles )
-	
-		throws PlatformManagerException
-	{
-		try{
-			access.createProcess( command_line, inherit_handles );
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to create process", e ));
-		}	
-	}
-	
-	public void
-    performRecoverableFileDelete(
-		String	file_name )
-	
-		throws PlatformManagerException
-	{
-		try{
-			access.moveToRecycleBin( file_name );
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to move file", e ));
-		}
-	}
-
-	public void
-	setTCPTOSEnabled(
-		boolean		enabled )
-		
-		throws PlatformManagerException
-	{
-		try{
-			access.writeWordValue( 	
-					AEWin32Access.HKEY_LOCAL_MACHINE,
-					"System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
-					"DisableUserTOSSetting",
-					enabled?0:1);
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to write registry details", e ));
-		}		
-	}
-
-	public void
-    copyFilePermissions(
-		String	from_file_name,
-		String	to_file_name )
-	
-		throws PlatformManagerException
-	{
-		try{
-			access.copyFilePermissions( from_file_name, to_file_name );
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to copy file permissions", e ));
-		}		
-	}
-	
-    /**
-     * {@inheritDoc}
-     */
-    public void showFile(String file_name)
-
-            throws PlatformManagerException
-    {
-        try
-        {
-        	File file = new File(file_name);
-        	
-        	access.createProcess( "explorer.exe " + ( file.isDirectory() ? "/e," : "/e,/select," ) + "\"" + file_name + "\"", false );
-        	
-        	/*
-        	Runtime.getRuntime().exec(
-        			new String[] { "explorer.exe",
-        					file.isDirectory() ? "/e," : "/e,/select,",
-        							"\"" + file_name + "\"" });
-        							*/
-        }
-        catch (Throwable e)
-        {
-            throw new PlatformManagerException("Failed to show file " + file_name, e);
-        }
-    }
-
-	public boolean
-	testNativeAvailability(
-		String	name )
-	
-		throws PlatformManagerException
-	{
-		if ( !hasCapability( PlatformManagerCapabilities.TestNativeAvailability )){
-			
-			throw new PlatformManagerException("Unsupported capability called on platform manager");
-		}
-		
-		try{
-			return( access.testNativeAvailability( name ));
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to test availability", e ));
-		}
-	}
-	
-	public void
-	traceRoute(
-		InetAddress							interface_address,
-		InetAddress							target,
-		PlatformManagerPingCallback			callback )
-	
-		throws PlatformManagerException
-	{
-		if ( !hasCapability( PlatformManagerCapabilities.TraceRouteAvailability )){
-			
-			throw new PlatformManagerException("Unsupported capability called on platform manager");
-		}
-		
-		try{
-			access.traceRoute( interface_address, target, callback );
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to trace route", e ));
-		}	
-	}
-	
-	public void
-	ping(
-		InetAddress							interface_address,
-		InetAddress							target,
-		PlatformManagerPingCallback			callback )
-	
-		throws PlatformManagerException
-	{
-		if ( !hasCapability( PlatformManagerCapabilities.PingAvailability )){
-			
-			throw new PlatformManagerException("Unsupported capability called on platform manager");
-		}
-		
-		try{
-			access.ping( interface_address, target, callback );
-			
-		}catch( Throwable e ){
-			
-			throw( new PlatformManagerException( "Failed to trace route", e ));
-		}	
-	}
-	
-	public int shellExecute(String operation, String file, String parameters,
-			String directory, int SW_const) throws PlatformManagerException {
-		try {
-			return access.shellExecute(operation, file, parameters, directory, SW_const);
-		} catch (Throwable e) {
-			throw( new PlatformManagerException( "Failed to shellExecute", e ));
-		}
-	}
-
-	
-    /**
-     * {@inheritDoc}
-     */
-    public boolean
-    hasCapability(
-            PlatformManagerCapabilities capability)
-    {
-        return capabilitySet.contains(capability);
-    }
-
-    /**
-     * Does nothing
-     */
-    public void dispose()
-    {
-    }
-    
-	public void
-	eventOccurred(
-		int		type )
-	{
-		int	t_type;
-		
-		if ( type == AEWin32AccessListener.ET_SHUTDOWN ){
-			
-			t_type = PlatformManagerListener.ET_SHUTDOWN;
-			
-		}else if ( type == AEWin32AccessListener.ET_SUSPEND ){
-			
-			t_type = PlatformManagerListener.ET_SUSPEND;
-				
-		}else if ( type == AEWin32AccessListener.ET_RESUME ){
-			
-			t_type = PlatformManagerListener.ET_RESUME;
-				
-		}else{
-			
-			return;
-		}
-		
-		if ( t_type != -1 ){
-			
-			for (int i=0;i<listeners.size();i++){
-				
-				try{
-					((PlatformManagerListener)listeners.get(i)).eventOccurred( t_type );
-					
-				}catch( Throwable e ){
-					
-					Debug.printStackTrace(e);
-				}
-			}
-		}
-	}
-	
-    public void
-    addListener(
-    	PlatformManagerListener		listener )
-    {
-    	listeners.add( listener );
-    }
-    
-    public void
-    removeListener(
-    	PlatformManagerListener		listener )
-    {
-    	listeners.remove( listener );
-    }
-
-  /**
-   * Gets an ID to identify this computer to azureus.  Used when the computer
-   * has muliple user accounts and we need a way to not duplicate efforts
-   * (An example would be to skip downloading something another user on the
-   * computer has already downloaded)
-   * <p>
-   * The default for the ID is the AZID of the first user profile.
-	 * 
-	 * @return ID
-	 */
-	public String getAzComputerID() {
-		boolean needWrite = false;
-		String cid = null;
-		try {
-			cid = access.readStringValue(AEWin32Access.HKEY_LOCAL_MACHINE,
-					"SOFTWARE\\" + app_name, "CID");
-		} catch (Exception e) {
-		}
-
-		if (cid == null || cid.length() == 0) {
-			needWrite = true;
-			try {
-				File commonPath = new File(access.getCommonAppData(),app_name);
-				if (commonPath.isDirectory()) {
-					File fCID = new File(commonPath, "azCID.txt");
-					if (fCID.exists()) {
-						cid = FileUtil.readFileAsString(fCID, 255, "utf8");
-					}
-				}
-			} catch (Exception e) {
-			}
-		}
-
-		if (cid == null || cid.length() == 0) {
-			needWrite = true;
-			cid = COConfigurationManager.getStringParameter("ID");
-		}
-
-		if (cid == null || cid.length() == 0) {
-			needWrite = true;
-			cid = RandomUtils.generateRandomAlphanumerics(20);
-		}
-
-		if (needWrite) {
-			setAzComputerID(cid);
-		}
-		return cid;
-	}
-
-	/**
-	 * @param cid
-	 */
-	private void setAzComputerID(String cid) {
-		try {
-			access.writeStringValue(AEWin32Access.HKEY_LOCAL_MACHINE,
-					"SOFTWARE\\" + app_name, "CID", cid);
-		} catch (Exception e) {
-			Debug.out("Could not write CID: " + e.getMessage());
-		}
-
-		try {
-			String sCommonAppData = access.getCommonAppData();
-			if (sCommonAppData != null && sCommonAppData.length() > 0) {
-				File commonPath = new File(sCommonAppData);
-				if (commonPath.isDirectory()) {
-					commonPath = new File(commonPath, app_name);
-					FileUtil.mkdirs(commonPath);
-
-					File fCID = new File(commonPath, "azCID.txt");
-					FileUtil.writeBytesAsFile(fCID.getAbsolutePath(),
-							cid.getBytes("utf8"));
-				}
-			}
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-	}
-	
-	public static void main(String[] args) {
-		try {
-			PlatformManagerImpl impl = new PlatformManagerImpl();
-			System.out.println(impl.getAzComputerID());
-		} catch (PlatformManagerException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		
-	}
-
-	public void requestUserAttention(int type, Object data) throws PlatformManagerException {
-		throw new PlatformManagerException("Unsupported capability called on platform manager");
-	}
-}
diff -urN org/gudy/azureus2/platform.orig/win32/PlatformManagerUpdateChecker.java org/gudy/azureus2/platform/win32/PlatformManagerUpdateChecker.java
--- org/gudy/azureus2/platform.orig/win32/PlatformManagerUpdateChecker.java	2008-03-10 07:33:50.000000000 -0700
+++ org/gudy/azureus2/platform/win32/PlatformManagerUpdateChecker.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,361 +0,0 @@
-/*
- * Created on 07-May-2004
- * Created by Paul Gardner
- * Copyright (C) 2004, 2005, 2006 Aelitis, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- * 
- * AELITIS, SAS au capital de 46,603.30 euros
- * 8 Allee Lenotre, La Grille Royale, 78600 Le Mesnil le Roi, France.
- *
- */
-
-package org.gudy.azureus2.platform.win32;
-
-/**
- * @author parg
- *
- */
-
-import java.io.*;
-import java.util.*;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import java.net.*;
-
-import org.gudy.azureus2.core3.util.*;
-import org.gudy.azureus2.core3.html.HTMLUtils;
-import org.gudy.azureus2.core3.logging.*;
-import org.gudy.azureus2.platform.*;
-import org.gudy.azureus2.plugins.utils.resourcedownloader.*;
-import org.gudy.azureus2.pluginsimpl.local.utils.resourcedownloader.*;
-import org.gudy.azureus2.plugins.*;
-import org.gudy.azureus2.plugins.update.*;
-import org.gudy.azureus2.pluginsimpl.update.sf.*;
-
-public class 
-PlatformManagerUpdateChecker
-	implements Plugin, UpdatableComponent
-{
-	private static final LogIDs LOGID = LogIDs.CORE;
-	public static final String UPDATE_NAME	= "Platform-specific support";
-	
-	public static final int	RD_SIZE_RETRIES	= 3;
-	public static final int	RD_SIZE_TIMEOUT	= 10000;
-	
-	protected PluginInterface			plugin_interface;
-	
-	public void
-	initialize(
-		PluginInterface	_plugin_interface)
-	{
-		plugin_interface	= _plugin_interface;
-		
-		plugin_interface.getPluginProperties().setProperty( "plugin.name", "Platform-Specific Support" );
-
-		String	version = "1.0";	// default version if plugin not present
-		
-		PlatformManager platform	= PlatformManagerFactory.getPlatformManager();
-
-		if (  platform.getPlatformType() == PlatformManager.PT_WINDOWS ){
-
-			if ( platform.hasCapability( PlatformManagerCapabilities.GetVersion )){
-				
-				try{
-					version = platform.getVersion();
-					
-				}catch( Throwable e ){
-					
-					Debug.printStackTrace(e);
-				}
-			}
-			
-			plugin_interface.getUpdateManager().registerUpdatableComponent( this, false );
-			
-		}else{
-			
-			plugin_interface.getPluginProperties().setProperty( "plugin.version.info", "Not required for this platform" );
-			
-		}
-		
-		plugin_interface.getPluginProperties().setProperty( "plugin.version", version );
-	}
-	
-	public String
-	getName()
-	{
-		return( UPDATE_NAME );
-	}
-	
-	public int
-	getMaximumCheckTime()
-	{
-		return(( RD_SIZE_RETRIES * RD_SIZE_TIMEOUT )/1000);
-	}
-	
-	public void
-	checkForUpdate(
-		final UpdateChecker	checker )
-	{
-		try{						
-			SFPluginDetails	sf_details = SFPluginDetailsLoaderFactory.getSingleton().getPluginDetails( plugin_interface.getPluginID());
-					
-			String	current_version = plugin_interface.getPluginVersion();
-			
-			if (Logger.isEnabled())
-				Logger.log(new LogEvent(LOGID,
-						"PlatformManager:Win32 update check starts: current = "
-								+ current_version));
-						
-			boolean current_az_is_cvs	= Constants.isCVSVersion();
-						
-			String sf_plugin_version	= sf_details.getVersion();
-			
-			String sf_comp_version	 	= sf_plugin_version;
-	
-			if ( current_az_is_cvs ){
-				
-				String	sf_cvs_version = sf_details.getCVSVersion();
-				
-				if ( sf_cvs_version.length() > 0 ){
-					
-						// sf cvs version ALWAYS entry in _CVS
-					
-					sf_plugin_version	= sf_cvs_version;
-					
-					sf_comp_version = sf_plugin_version.substring(0,sf_plugin_version.length()-4);
-				}
-			}
-			
-			String	target_version	= null;			
-
-			if (	 sf_comp_version.length() == 0 ||
-					!Character.isDigit(sf_comp_version.charAt(0))){
-				
-				if (Logger.isEnabled())
-					Logger.log(new LogEvent(LOGID, LogEvent.LT_WARNING,
-							"PlatformManager:Win32 no valid version to check against ("
-									+ sf_comp_version + ")"));
-
-			}else if ( Constants.compareVersions( current_version, sf_comp_version ) < 0 ){
-				
-				target_version	= sf_comp_version;
-			}
-	
-			checker.reportProgress( "Win32: current = " + current_version + ", latest = " + sf_comp_version );
-			
-			if (Logger.isEnabled())
-				Logger.log(new LogEvent(LOGID,
-						"PlatformManager:Win32 update required = "
-								+ (target_version != null)));
-			
-			if ( target_version != null ){
-					
-				String target_download		= sf_details.getDownloadURL();
-		
-				if ( current_az_is_cvs ){
-					
-					String	sf_cvs_version = sf_details.getCVSVersion();
-					
-					if ( sf_cvs_version.length() > 0 ){
-												
-						target_download	= sf_details.getCVSDownloadURL();
-					}
-				}				
-
-				ResourceDownloaderFactory rdf = ResourceDownloaderFactoryImpl.getSingleton();
-				
-				ResourceDownloader direct_rdl = rdf.create( new URL( target_download ));
-			
-				String	torrent_download = Constants.AELITIS_TORRENTS;
-				
-				int	slash_pos = target_download.lastIndexOf("/");
-				
-				if ( slash_pos == -1 ){
-					
-					torrent_download += target_download;
-					
-				}else{
-					
-					torrent_download += target_download.substring( slash_pos + 1 );
-				}
-				
-				torrent_download	+= ".torrent";
-				
-				ResourceDownloader torrent_rdl = rdf.create( new URL( torrent_download ));
-
-				torrent_rdl	= rdf.getSuffixBasedDownloader( torrent_rdl );
-				
-					// create an alternate downloader with torrent attempt first
-				
-				ResourceDownloader alternate_rdl = rdf.getAlternateDownloader( new ResourceDownloader[]{ torrent_rdl, direct_rdl });
-
-					// get size here so it is cached
-				
-				rdf.getTimeoutDownloader(rdf.getRetryDownloader(alternate_rdl,RD_SIZE_RETRIES),RD_SIZE_TIMEOUT).getSize();
-				
-			
-				List	update_desc = new ArrayList();
-				
-				List	desc_lines = HTMLUtils.convertHTMLToText( "", sf_details.getDescription());
-								
-				update_desc.addAll( desc_lines );
-								
-				List	comment_lines = HTMLUtils.convertHTMLToText( "    ", sf_details.getComment());
-				
-				update_desc.addAll( comment_lines );
-
-				String[]	update_d = new String[update_desc.size()];
-				
-				update_desc.toArray( update_d );
-
-				final Update	update = 
-					checker.addUpdate(
-						UPDATE_NAME,
-						update_d,
-						target_version,
-						alternate_rdl,
-						Update.RESTART_REQUIRED_YES );
-				
-				update.setDescriptionURL(sf_details.getInfoURL());
-				
-				alternate_rdl.addListener( 
-						new ResourceDownloaderAdapter()
-						{
-							public boolean
-							completed(
-								final ResourceDownloader	downloader,
-								InputStream					data )
-							{	
-								installUpdate( checker, update, downloader, data );
-									
-								return( true );
-							}							
-						});
-			}
-		}catch( Throwable e ){
-			
-			Debug.printStackTrace( e );
-			
-			checker.reportProgress( "Failed to load plugin details for the platform manager: " + Debug.getNestedExceptionMessage(e));
-			
-			checker.failed();
-			
-		}finally{
-			
-			checker.completed();
-		}
-	}
-	
-	protected void
-	installUpdate(
-		UpdateChecker		checker,
-		Update 				update,
-		ResourceDownloader	rd,
-		InputStream			data )
-	{
-		ZipInputStream zip = null;
-		
-		try {
-			data = update.verifyData( data, true );
-
-			rd.reportActivity( "Data verified successfully" );
-			
-			UpdateInstaller installer = checker.createInstaller();
-
-			zip = new ZipInputStream(data);
-
-			ZipEntry entry = null;
-
-			while ((entry = zip.getNextEntry()) != null) {
-
-				String name = entry.getName();
-
-				if (name.toLowerCase().startsWith("windows/")) {
-
-					// win32 only files
-
-					name = name.substring(8);
-
-					// skip the directory entry
-
-					if (name.length() > 0) {
-
-						rd.reportActivity("Adding update action for '" + name + "'");
-
-						if (Logger.isEnabled())
-							Logger.log(new LogEvent(LOGID,
-									"PlatformManager:Win32 adding action for '" + name + "'"));
-
-						installer.addResource(name, zip, false);
-
-						installer.addMoveAction(name, installer.getInstallDir()
-								+ File.separator + name);
-					}
-				}
-			}
-		} catch (Throwable e) {
-
-			rd.reportActivity("Update install failed:" + e.getMessage());
-		}finally{
-			
-			if ( zip != null ){
-				
-				try{
-					zip.close();
-					
-				}catch( Throwable e ){
-				}
-			}
-		}
-	}
-	
-	protected List
-	splitMultiLine(
-		String		indent,
-		String		text )
-	{
-		int		pos = 0;
-		
-		String	lc_text = text.toLowerCase();
-		
-		List	lines = new ArrayList();
-		
-		while( true ){
-			
-			String	line;
-			
-			int	p1 = lc_text.indexOf( "<br>", pos );
-			
-			if ( p1 == -1 ){
-				
-				line = text.substring(pos);
-				
-			}else{
-				
-				line = text.substring(pos,p1);
-				
-				pos = p1+4;
-			}
-			
-			lines.add( indent + line );
-			
-			if ( p1 == -1 ){
-				
-				break;
-			}
-		}
-		
-		return( lines );
-	}
-}
